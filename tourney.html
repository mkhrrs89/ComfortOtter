<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ModelMatchup ‚Äî Tournament Mode</title>
  <meta name="theme-color" content="#050c0a" />
  <link rel="stylesheet" href="app-style.css" />
  <style>
    :root{
      --bg:#050c0a;
      --panel:#091612;
      --panel-soft:#0e1f1a;
      --muted:#8fb0a1;
      --text:#e7f5ef;
      --accent:#1f9d73;
      --accent-soft:#153e30;
      --danger:#ff5f71;
      --ghost:#182621;
      --ring:#1b3a2f;
      --card:#07100d;
      --border-soft:#123427;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      background:radial-gradient(circle at top,#103828 0,#050c0a 55%);
      color:var(--text);
      font:14px/1.4 system-ui,Segoe UI,Roboto,Arial,sans-serif;
    }
    .app{
      max-width:1180px;
      margin:0 auto;
      padding:16px 20px 40px;
    }
    .header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:16px;
      margin-bottom:10px;
    }
    h1{
      font-size:22px;
      margin:0;
      letter-spacing:0.03em;
    }
    .tabs{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
    }
    .tab{
      background:var(--panel);
      color:var(--text);
      border:1px solid var(--ring);
      padding:7px 11px;
      border-radius:999px;
      cursor:pointer;
      font-size:13px;
      text-decoration:none;
      display:inline-flex;
      align-items:center;
      justify-content:center;
    }
    .tab.active{
      outline:2px solid var(--accent);
      background:linear-gradient(135deg,#1f9d73,#157457);
    }
    .pane{
      background:var(--panel);
      border:1px solid var(--ring);
      border-radius:14px;
      padding:14px;
      margin-bottom:14px;
    }
    .btn{
      background:var(--accent);
      color:white;
      border:none;
      padding:7px 11px;
      border-radius:10px;
      cursor:pointer;
      font-size:13px;
      display:inline-flex;
      align-items:center;
      gap:6px;
      -webkit-tap-highlight-color: transparent;
    }
    .btn.sm{padding:5px 9px;font-size:12px}
    .btn.ghost{background:var(--ghost);}
    .btn.danger{background:var(--danger);}
    .btn[disabled]{opacity:0.5;cursor:default;}
    .toolbar{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      align-items:center;
      justify-content:space-between;
      margin-bottom:8px;
    }
    .smallMuted{
      font-size:11px;
      color:var(--muted);
    }
    .hint{color:var(--muted);padding:8px 0;font-size:13px}
    .pill{
      border-radius:999px;
      padding:2px 7px;
      font-size:11px;
      background:var(--accent-soft);
      border:1px solid var(--ring);
      color:#c5f4dc;
    }
    /* Match layout */
    .arena{
      display:grid;
      grid-template-columns:1fr auto 1fr;
      align-items:center;
      gap:12px;
      margin:10px 0 6px;
    }
    .imageCard{
      position:relative;
      border:1px solid var(--ring);
      border-radius:14px;
      overflow:hidden;
      cursor:pointer;
      background:#000;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:4px;
      -webkit-tap-highlight-color: transparent;
    }
    .imageCardBtn{
      border:none;
      background:none;
      padding:0;
      margin:0;
      display:block;
      width:100%;
      cursor:pointer;
    }
    .imageCard img{
      width:100%;
      height:64vh;
      max-height:520px;
      object-fit:contain;
      background:#000;
      display:block;
    }
    .imageCard.imageFailed{
      border-style:dashed;
      border-color:rgba(255,255,255,0.2);
    }
    .imageFailureMsg{
      color:var(--muted);
      font-size:12px;
      padding:16px;
      text-align:center;
    }
    .vs{
      font-weight:700;
      opacity:0.8;
      font-size:16px;
    }
    .matchMetaRow{
      display:grid;
      grid-template-columns:1fr auto 1fr;
      gap:12px;
      align-items:flex-start;
      margin-bottom:6px;
      font-size:13px;
    }
    .matchMetaBox{
      background:var(--panel-soft);
      border-radius:10px;
      padding:6px 8px;
      border:1px solid var(--ring);
      display:flex;
      flex-direction:column;
      gap:3px;
    }
    .matchMetaTitle{
      font-size:11px;
      color:var(--muted);
      text-transform:uppercase;
      letter-spacing:0.06em;
    }
    .matchMetaStats{
      font-size:13px;
    }
    .matchFooter{
      display:flex;
      justify-content:center;
      gap:8px;
      margin-top:4px;
    }
    .badge{
      border-radius:999px;
      padding:2px 5px;
      font-size:11px;
      line-height:1.1;
      background:rgba(0,0,0,0.7);
      border:1px solid rgba(255,255,255,0.18);
      display:inline-flex;
      align-items:center;
      justify-content:center;
    }
    .badge.gold{
      background:linear-gradient(135deg,#fce38a,#f5a623);
      border-color:#f8d35a;
      color:#251a03;
    }

    /* Bracket */
    .tBracketWrapper{
      margin-top:14px;
      border-top:1px solid var(--ring);
      padding-top:10px;
    }
    .tBracket{
      display:flex;
      gap:10px;
      overflow-x:auto;
      padding-bottom:4px;
    }
    .tRoundCol{
      min-width:150px;
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    .tRoundTitle{
      font-size:12px;
      color:var(--muted);
      text-transform:uppercase;
      letter-spacing:0.08em;
      margin-bottom:2px;
    }
    .tMatchPair{
      background:var(--panel-soft);
      border-radius:8px;
      border:1px solid var(--ring);
      padding:4px 6px;
      display:flex;
      flex-direction:column;
      gap:2px;
      font-size:12px;
    }
    .tSlot{
      padding:2px 4px;
      border-radius:4px;
      background:rgba(0,0,0,0.3);
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }
    .tSlot.tWinner{
      background:rgba(31,157,115,0.35);
      border:1px solid var(--accent);
    }
    .champCard{
      display:grid;
      grid-template-columns:minmax(0,1fr) minmax(0,2fr);
      gap:12px;
      align-items:center;
      margin-top:8px;
    }
    .champImgWrap{
      border-radius:12px;
      border:1px solid var(--ring);
      background:#000;
      overflow:hidden;
    }
    .champImgWrap img{
      width:100%;
      height:auto;
      display:block;
      object-fit:contain;
    }
    .champMetaTitle{
      font-size:14px;
      font-weight:600;
      margin-bottom:4px;
    }
    .champMetaLine{
      font-size:12px;
      color:var(--muted);
      margin-bottom:2px;
    }
    @media (max-width:800px){
      .champCard{
        grid-template-columns:1fr;
      }
    }
  </style>
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-app.js";
    import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-auth.js";
    import { getStorage, ref, getDownloadURL } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-storage.js";

    const firebaseConfig = {
      apiKey: "AIzaSyBOVGz7QH_iPtxoM25baGqTIR-2yxUQwH8",
      authDomain: "comforting-otter.firebaseapp.com",
      projectId: "comforting-otter",
      storageBucket: "comforting-otter.firebasestorage.app",
      messagingSenderId: "1074346290690",
      appId: "1:1074346290690:web:bd2721e73fbdf029e7411b",
      measurementId: "G-2JT31JFGNJ"
    };

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const storage = getStorage(app);

    signInAnonymously(auth).catch(err => {
      console.error("Anonymous sign-in failed:", err);
    });

    window.fetchFullImageUrl = async function fetchFullImageUrl(id){
      if(!id) return null;
      try{
        const storageRef = ref(storage, `images/${id}.jpg`);
        return await getDownloadURL(storageRef);
      }catch(err){
        console.warn('Full image URL unavailable from Firebase', err);
        return null;
      }
    };
  </script>
</head>
<body>
  <div class="app">
    <header class="header">
      <h1>ModelMatchup ‚Äî Tournament</h1>
      <div class="navMenuShell">
        <details class="navDropdown">
          <summary class="navTrigger">Menu ‚ñæ</summary>
          <div class="navMenuList">
            <a class="navItem" href="index.html?tab=Library">Library</a>
            <a class="navItem" href="index.html?tab=Matchups">Matchups</a>
            <a class="navItem" href="index.html?tab=Stats">Stats</a>
            <a class="navItem" href="index.html?tab=Collections">Collections</a>
            <div class="navSpacer"></div>
            <a class="navItem active" href="tourney.html">Tournament</a>
            <a class="navItem" href="settings.html">Settings</a>
          </div>
        </details>
      </div>
    </header>

    <section class="pane">
      <div class="toolbar">
        <div>
          <span id="tStatus" class="smallMuted"></span>
        </div>
        <div id="tControls">
          <!-- buttons injected by JS -->
        </div>
      </div>

      <div id="tHint" class="hint"></div>

      <div id="tMatch">
        <!-- current matchup injected -->
      </div>

      <div id="tBracket" class="tBracketWrapper">
        <!-- bracket injected -->
      </div>
    </section>
  </div>

  <script>

function isNonEmptySrc(src){
  return typeof src === 'string' && src.trim().length > 0;
}

function dedupeSources(list){
  const seen = new Set();
  const clean = [];
  for(const src of list){
    if(!isNonEmptySrc(src)) continue;
    if(seen.has(src)) continue;
    seen.add(src);
    clean.push(src);
  }
  return clean;
}

function getThumbOnlySources(item){
  if (!item) return [];
  return dedupeSources([
    item.thumbnail,
    item.thumbDataUrl
  ]);
}

function getFullOnlySources(item){
  if (!item) return [];
  return dedupeSources([
    item.fullUrl,
    item.dataUrl
  ]);
}

function getDisplaySources(item){
  return getThumbOnlySources(item);
}

function getDisplaySrc(item){
  const sources = getDisplaySources(item);
  return sources[0] || "";
}

function isHttpUrl(str){
  return typeof str === 'string' && /^https?:\/\//i.test(str);
}


function preloadImage(src){
  if (!src) return;
  const img = new Image();
  img.src = src;
}

function serializeSources(sources){
  return sources.map(src => encodeURIComponent(src)).join('|');
}

function parseSources(serialized){
  if(!serialized) return [];
  return serialized.split('|').map(part => decodeURIComponent(part)).filter(Boolean);
}

function advanceImageFallback(imgEl){
  if(!imgEl) return;
  const sources = parseSources(imgEl.dataset.srcs || '');
  const currentIndex = Number(imgEl.dataset.srcIndex || 0);
  const nextIndex = currentIndex + 1;
  if(nextIndex >= sources.length) return false;
  imgEl.dataset.srcIndex = String(nextIndex);
  imgEl.src = sources[nextIndex];
  return true;
}

function showImageFailure(imgEl, reason){
  if(!imgEl || imgEl.dataset.failureShown) return;
  imgEl.dataset.failureShown = 'true';
  const wrapper = imgEl.closest('.imageCard') || imgEl.parentElement;
  if(!wrapper) return;
  wrapper.classList.add('imageFailed');
  const msg = document.createElement('div');
  msg.className = 'imageFailureMsg';
  msg.textContent = reason;
  wrapper.appendChild(msg);
  imgEl.style.display = 'none';
}

function attachImageFallbacks(rootEl){
  if(!rootEl) return;
  const imgs = rootEl.querySelectorAll('img[data-srcs]');
  imgs.forEach(img => {
    if(img.dataset.fallbackBound) return;
    img.dataset.fallbackBound = 'true';
    const sources = parseSources(img.dataset.srcs || '');
    if(!sources.length){
      showImageFailure(img, 'Image unavailable: no source URL found.');
      return;
    }
    img.addEventListener('error', () => {
      const advanced = advanceImageFallback(img);
      if(!advanced){
        showImageFailure(img, 'Image unavailable: all available sources failed to load.');
      }
    });
  });
}

function attachHdButtons(rootEl){
  if(!rootEl) return;
  const buttons = rootEl.querySelectorAll('[data-hd-target]');
  buttons.forEach(btn => {
    if(btn.dataset.hdBound) return;
    btn.dataset.hdBound = 'true';
    const targetId = btn.dataset.hdTarget;
    const img = document.getElementById(targetId);
    if(!img) return;
    const fullSources = parseSources(img.dataset.fullSrcs || '');
    if(!fullSources.length){
      btn.disabled = true;
      btn.textContent = 'HD unavailable';
      return;
    }
    btn.addEventListener('click', (ev)=>{
      ev.preventDefault();
      ev.stopPropagation();
      const sources = parseSources(img.dataset.fullSrcs || '');
      if(!sources.length) return;
      img.dataset.srcs = serializeSources(sources);
      img.dataset.srcIndex = '0';
      img.src = sources[0];
      btn.disabled = true;
      btn.textContent = 'HD loaded';
    });
  });
}


    // Helper: bind tap for buttons (not images)
    function addTap(el, handler){
      if(!el) return;
      let locked = false;
      const wrapped = (ev)=>{
        ev.preventDefault();
        ev.stopPropagation();
        if(locked) return;
        locked = true;
        try{ handler(); } finally {
          setTimeout(()=>{ locked = false; }, 150);
        }
      };
      el.addEventListener('click', wrapped);
      el.addEventListener('touchstart', wrapped, {passive:false});
    }

    // === MAIN ITEMS DB (same as index.html) ===
    const DB_NAME = 'modelMatchupDB';
    const DB_STORE = 'items';

    // === TOURNAMENT STATE DB ===
    const TOURNEY_DB_NAME = 'modelMatchupTourneyDB';
    const TOURNEY_STORE = 'tourneyState_256';
    const TOURNEY_STATE_ID = 'tourneyState_256';

    function openItemsDB(){
      return new Promise((resolve,reject)=>{
        const req = indexedDB.open(DB_NAME);
        req.onupgradeneeded = () => {
          const db = req.result;
          if(!db.objectStoreNames.contains(DB_STORE)){
            db.createObjectStore(DB_STORE,{keyPath:'id'});
          }
        };
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
      });
    }

    function openTourneyDB(){
      return new Promise((resolve,reject)=>{
        const req = indexedDB.open(TOURNEY_DB_NAME,1);
        req.onupgradeneeded = () => {
          const db = req.result;
          if(!db.objectStoreNames.contains(TOURNEY_STORE)){
            db.createObjectStore(TOURNEY_STORE,{keyPath:'id'});
          }
        };
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
      });
    }

    async function idbGetAllItems(){
      const db = await openItemsDB();
      return new Promise((res,rej)=>{
        const tx = db.transaction(DB_STORE,'readonly');
        const st = tx.objectStore(DB_STORE);
        const out = [];
        const cur = st.openCursor();
        cur.onsuccess = e=>{
          const c = e.target.result;
          if(c){ out.push(c.value); c.continue(); }
          else res(out);
        };
        cur.onerror = ()=>rej(cur.error);
      });
    }

    async function idbPutItem(item){
      const db = await openItemsDB();
      return new Promise((res,rej)=>{
        const tx = db.transaction(DB_STORE,'readwrite');
        tx.objectStore(DB_STORE).put(item);
        tx.oncomplete = ()=>res();
        tx.onerror = ()=>rej(tx.error);
      });
    }

    async function loadTourneyState(){
      const db = await openTourneyDB();
      return new Promise((res,rej)=>{
        const tx = db.transaction(TOURNEY_STORE,'readonly');
        const st = tx.objectStore(TOURNEY_STORE);
        const req = st.get(TOURNEY_STATE_ID);
        req.onsuccess = ()=>res(req.result || null);
        req.onerror = ()=>rej(req.error);
      });
    }

    async function saveTourneyState(state){
      const db = await openTourneyDB();
      return new Promise((res,rej)=>{
        const tx = db.transaction(TOURNEY_STORE,'readwrite');
        const st = tx.objectStore(TOURNEY_STORE);
        st.put({...state,id:TOURNEY_STATE_ID});
        tx.oncomplete = ()=>res();
        tx.onerror = ()=>rej(tx.error);
      });
    }

    async function clearTourneyState(){
      const db = await openTourneyDB();
      return new Promise((res,rej)=>{
        const tx = db.transaction(TOURNEY_STORE,'readwrite');
        const st = tx.objectStore(TOURNEY_STORE);
        st.delete(TOURNEY_STATE_ID);
        tx.oncomplete = ()=>res();
        tx.onerror = ()=>rej(tx.error);
      });
    }

    function pct(w,l){
      const t = (w||0)+(l||0);
      return t===0 ? 0 : (w||0)/t;
    }
    function matchupsCount(it){
      return (it.wins||0)+(it.losses||0);
    }
function computePoints(w,l,tourneyBonus){
  const W = w||0;
  const L = l||0;
  const B = tourneyBonus||0;
  let pts = W*2 - L + B;
  if(W>0 && L===0) pts += 5;
  return pts;
}

function metricValue(item, metric){
  if(metric === 'wins') return Number(item && item.wins || 0);
  return computePoints(item && item.wins, item && item.losses, item && item.tourneyBonus||0);
}

function buildTopPoolOptions(allItems){
  if(!Array.isArray(allItems) || allItems.length === 0) return [];

  const percents = [10,25,50];
  const metrics = [
    {key:'points', label:'points'},
    {key:'wins', label:'wins'}
  ];

  const pools = [];

  for(const metric of metrics){
    const sorted = allItems.slice().sort((a,b)=> metricValue(b, metric.key) - metricValue(a, metric.key));
    for(const pct of percents){
      const count = Math.max(1, Math.floor(sorted.length * (pct/100)));
      pools.push({
        value: `__TOP_${metric.key.toUpperCase()}_${pct}__`,
        label: `Top ${pct}% by ${metric.label}`,
        count
      });
    }
  }

  return pools;
}

function describePool(value){
  if(!value || value === '__ALL__') return 'All images';
  if(value === '__RECENT_256__') return 'Most recent 256';
  if(value === '__NEVER_TOURNEY__') return 'Never in a tournament';
  if(value === '__FEWEST_TOURNEYS__') return 'Fewest tournaments';
  if(value === '__TOP_WINPCT_25_BOTTOM_MATCHUPS_50__') return 'Top 25% win% & bottom 50% matchups';
  const topMatch = /^__TOP_(POINTS|WINS)_(\d+)__$/i.exec(value);
  if(topMatch){
    const metric = topMatch[1].toLowerCase() === 'wins' ? 'wins' : 'points';
    return `Top ${topMatch[2]}% by ${metric}`;
  }
  return value;
}

function describeTagPool(value){
  if(!value || value === '__ALL_TAGS__') return 'All tags';
  return value;
}

function applyPoolFilter(allItems, poolValue){
  if(!poolValue || poolValue === '__ALL__') return allItems.slice();

  if(poolValue === '__RECENT_256__'){
    const sorted = allItems.slice().sort((a,b)=>{
      const ta = new Date(a.addedAt || 0).getTime();
      const tb = new Date(b.addedAt || 0).getTime();
      return tb - ta;
    });
    return sorted.slice(0, 256);
  }

  if(poolValue === '__NEVER_TOURNEY__'){
    return allItems.filter(it => Number(it.tourneyCount || 0) === 0);
  }

  if(poolValue === '__FEWEST_TOURNEYS__'){
    const minCount = allItems.reduce((min, it)=> Math.min(min, Number(it.tourneyCount || 0)), Infinity);
    if(!Number.isFinite(minCount)) return [];
    return allItems.filter(it => Number(it.tourneyCount || 0) === minCount);
  }

  if(poolValue === '__TOP_WINPCT_25_BOTTOM_MATCHUPS_50__'){
    const winPctSorted = allItems.slice().sort((a,b)=> pct(b.wins, b.losses) - pct(a.wins, a.losses));
    const topCount = Math.max(1, Math.floor(winPctSorted.length * 0.25));
    const topIds = new Set(winPctSorted.slice(0, topCount).map(it => it.id));
    const matchupsSorted = allItems.slice().sort((a,b)=> matchupsCount(a) - matchupsCount(b));
    const bottomCount = Math.max(1, Math.floor(matchupsSorted.length * 0.5));
    const bottomIds = new Set(matchupsSorted.slice(0, bottomCount).map(it => it.id));
    return allItems.filter(it => topIds.has(it.id) && bottomIds.has(it.id));
  }

  // Top X% pools
  const topMatch = /^__TOP_(POINTS|WINS)_(\d+)__$/i.exec(poolValue);
  if(topMatch){
    const metric = topMatch[1].toLowerCase() === 'wins' ? 'wins' : 'points';
    const pct = Number(topMatch[2]);
    const sorted = allItems.slice().sort((a,b)=> metricValue(b, metric) - metricValue(a, metric));
    const count = Math.max(1, Math.floor(sorted.length * (pct/100)));
    return sorted.slice(0, count);
  }

  // Collection-specific pools
  return allItems.filter(it =>
    Array.isArray(it.collections) && it.collections.includes(poolValue)
  );
}

function applyTagPoolFilter(allItems, tagValue){
  if(!tagValue || tagValue === '__ALL_TAGS__') return allItems.slice();
  return allItems.filter(it =>
    Array.isArray(it.collections) && it.collections.includes(tagValue)
  );
}

async function maybeHydrateFullImage(item){
  if(!item || hydratingFullUrls.has(item.id)) return;
  if(item.fullUrl && isHttpUrl(item.fullUrl)) return;
  if(!window.fetchFullImageUrl) return;

  hydratingFullUrls.add(item.id);
  try{
    const url = await window.fetchFullImageUrl(item.id);
    if(url && url !== item.fullUrl){
      const updated = {...item, fullUrl: url};
      await idbPutItem(updated);
      itemsById.set(updated.id, updated);
      items = items.map(it => it.id === updated.id ? updated : it);
      renderAll();
    }
  }catch(err){
    console.warn('Full image hydration failed for', item && item.id, err);
  }finally{
    hydratingFullUrls.delete(item.id);
  }
}

function escapeHtml(str){
  return String(str).replace(/[&<>"']/g, s=>{
    switch(s){
      case '&': return '&amp;';
      case '<': return '&lt;';
      case '>': return '&gt;';
      case '"': return '&quot;';
      case "'": return '&#39;';
      default: return s;
    }
  });
}

    const statusEl = document.getElementById('tStatus');
    const controlsEl = document.getElementById('tControls');
    const hintEl = document.getElementById('tHint');
    const matchEl = document.getElementById('tMatch');
    const bracketEl = document.getElementById('tBracket');

let items = [];
let itemsById = new Map();
let tourneyState = null;
let isProcessing = false;
let currentPoolMode = 'single';
let currentPool = '__ALL__'; // "__ALL__" means use all images
let currentTagPool = '__ALL_TAGS__';
let currentOtherPool = '__ALL__';
let currentMaxFieldSize = 256;
const hydratingFullUrls = new Set();
const DISPLAY_TITLE_MAX_LENGTH = 20;

function formatDisplayTitle(value){
  const text = typeof value === 'string' ? value : '';
  if(!text) return '';
  return text.length > DISPLAY_TITLE_MAX_LENGTH
    ? `${text.slice(0, DISPLAY_TITLE_MAX_LENGTH)}‚Ä¶`
    : text;
}

    function roundLabel(size){
      if(size === 2) return 'Championship';
      if(size === 4) return 'Final 4';
      if(size === 8) return 'Elite 8';
      if(size === 16) return 'Sweet 16';
      return 'Round of '+size;
    }

    function getEntrantsForRound(size,state){
      if(!state) return [];
      if(size === state.initialSize){
        return state.participantIds || [];
      }
      const prevSize = size*2;
      const winners = (state.bracketProgress && state.bracketProgress[String(prevSize)]) || [];
      return winners;
    }

    function shortLabelForId(id){
      const it = itemsById.get(id);
      if(!it) return '(deleted)';
      if(it.title) return formatDisplayTitle(it.title);
      return id.slice(0,8);
    }

    function formatDate(dIso){
      if(!dIso) return '';
      try{
        const d = new Date(dIso);
        return d.toLocaleString();
      }catch(e){
        return dIso;
      }
    }

    async function initTournamentPage(){
      try{
        items = await idbGetAllItems();
        itemsById = new Map(items.map(it=>[it.id, it]));
        tourneyState = await loadTourneyState();
      }catch(e){
        console.error(e);
      }
      renderAll();
    }

    function isTourneyStateValid(state){
      if(!state) return false;
      if(!Array.isArray(state.participantIds) || state.participantIds.length < 2) return false;
      for(const id of state.participantIds){
        if(!itemsById.has(id)) return false;
      }
      return true;
    }

    function renderAll(){
      controlsEl.innerHTML = '';
      matchEl.innerHTML = '';
      bracketEl.innerHTML = '';
      hintEl.textContent = '';

      const totalImgs = items.length;

      if(!totalImgs){
        statusEl.textContent = 'No images found. Add images in the main app to run a tournament.';
        controlsEl.innerHTML = '<button class="btn" id="tBackBtn">Go to main app</button>';
        const backBtn = document.getElementById('tBackBtn');
        if(backBtn) addTap(backBtn, ()=>{ window.location.href = 'index.html'; });
        return;
      }

      if(!isTourneyStateValid(tourneyState)){
        tourneyState = null;
      }

if(!tourneyState){
  statusEl.textContent = 'No active tournament.';

  const baseHint =
    `Tournament uses up to ${currentMaxFieldSize} random images from the selected pool in a single-elimination bracket.`;
  hintEl.textContent = baseHint;

  // Build collection counts so we know which pools qualify (>= current field size)
  const collCounts = {};
  for(const it of items){
    if(Array.isArray(it.collections)){
      for(const c of it.collections){
        if(!c) continue;
        collCounts[c] = (collCounts[c] || 0) + 1;
      }
    }
  }

  const eligibleCollections = Object.entries(collCounts)
    .filter(([name,count]) => count >= currentMaxFieldSize)
    .sort((a,b) => a[0].localeCompare(b[0]));
  const tagCollections = Object.entries(collCounts)
    .filter(([name,count]) => count >= currentMaxFieldSize)
    .sort((a,b) => b[1] - a[1] || a[0].localeCompare(b[0]));

  const topPools = buildTopPoolOptions(items);
  const specialPoolValue = '__TOP_WINPCT_25_BOTTOM_MATCHUPS_50__';
  const specialPoolCount = applyPoolFilter(items, specialPoolValue).length;
  const neverTourneyCount = items.filter(it => Number(it.tourneyCount || 0) === 0).length;
  const minTourneyCount = items.reduce((min, it)=> Math.min(min, Number(it.tourneyCount || 0)), Infinity);
  const fewestTourneyCount = Number.isFinite(minTourneyCount)
    ? items.filter(it => Number(it.tourneyCount || 0) === minTourneyCount).length
    : 0;

  // Build the dropdown + button (layout B: Pool [select]   Start button)
  let fieldSizeHtml = '<div style="display:flex;align-items:center;gap:6px;flex-wrap:wrap;margin-bottom:6px;">';
  fieldSizeHtml += '<span class="smallMuted">Field size:</span>';
  fieldSizeHtml += '<select id="tFieldSizeSelect" style="font-size:13px;padding:4px 6px;border-radius:8px;border:1px solid var(--ring);background:var(--ghost);color:var(--text);">';
  fieldSizeHtml += '<option value="256"'+(currentMaxFieldSize===256?' selected':'')+'>256</option>';
  fieldSizeHtml += '<option value="128"'+(currentMaxFieldSize===128?' selected':'')+'>128</option>';
  fieldSizeHtml += '</select>';
  fieldSizeHtml += '</div>';

  let poolModeHtml = '<div style="display:flex;align-items:center;gap:10px;flex-wrap:wrap;margin-bottom:6px;">';
  poolModeHtml += '<span class="smallMuted">Pool mode:</span>';
  poolModeHtml += '<label style="display:flex;align-items:center;gap:6px;">' +
    '<input type="radio" name="tPoolMode" value="single"'+(currentPoolMode==='single'?' checked':'')+' /> Single filter</label>';
  poolModeHtml += '<label style="display:flex;align-items:center;gap:6px;">' +
    '<input type="radio" name="tPoolMode" value="dual"'+(currentPoolMode==='dual'?' checked':'')+' /> Tag + filter</label>';
  poolModeHtml += '</div>';

  let poolSelectHtml = '<div style="display:flex;align-items:center;gap:6px;flex-wrap:wrap;">';
  poolSelectHtml += '<span class="smallMuted">Pool:</span>';
  poolSelectHtml += '<select id="tPoolSelect" style="font-size:13px;padding:4px 6px;border-radius:8px;border:1px solid var(--ring);background:var(--ghost);color:var(--text);">';

  // "All images" option
  poolSelectHtml += '<option value="__ALL__"'+(currentPool==='__ALL__'?' selected':'')+'>All images</option>';

  const recentCount = Math.min(256, items.length);
  poolSelectHtml += '<option value="__RECENT_256__"'+(currentPool==='__RECENT_256__'?' selected':'')+'>Most recent 256 ('+recentCount+')</option>';

  poolSelectHtml += '<optgroup label="Tournament history">';
  poolSelectHtml += '<option value="__NEVER_TOURNEY__"'+(currentPool==='__NEVER_TOURNEY__'?' selected':'')+'>Never in a tournament ('+neverTourneyCount+')</option>';
  poolSelectHtml += '<option value="__FEWEST_TOURNEYS__"'+(currentPool==='__FEWEST_TOURNEYS__'?' selected':'')+'>Fewest tournaments (min '+(Number.isFinite(minTourneyCount) ? minTourneyCount : 0)+', '+fewestTourneyCount+')</option>';
  poolSelectHtml += '</optgroup>';

  if(topPools.length){
    poolSelectHtml += '<optgroup label="Top performers">';
    for(const opt of topPools){
      const sel = (currentPool === opt.value) ? ' selected' : '';
      poolSelectHtml += '<option value="'+opt.value+'"'+sel+'>'+escapeHtml(opt.label)+' ('+opt.count+')</option>';
    }
    poolSelectHtml += '</optgroup>';
  }

  poolSelectHtml += '<optgroup label="Targeted pools">';
  poolSelectHtml += '<option value="'+specialPoolValue+'"'+(currentPool===specialPoolValue?' selected':'')+'>Top 25% win% &amp; bottom 50% matchups ('+specialPoolCount+')</option>';
  poolSelectHtml += '</optgroup>';

  // One option per eligible collection
  for(const [name,count] of eligibleCollections){
    const sel = (currentPool === name) ? ' selected' : '';
    poolSelectHtml += '<option value="'+escapeHtml(name)+'"'+sel+'>'+
      escapeHtml(name)+' ('+count+')</option>';
  }

  poolSelectHtml += '</select>';
  poolSelectHtml += '</div>';

  let tagSelectHtml = '<div id="tDualPoolControls" style="display:flex;flex-direction:column;gap:6px;">';
  tagSelectHtml += '<div style="display:flex;align-items:center;gap:6px;flex-wrap:wrap;">';
  tagSelectHtml += '<span class="smallMuted">Tag:</span>';
  tagSelectHtml += '<select id="tTagPoolSelect" style="font-size:13px;padding:4px 6px;border-radius:8px;border:1px solid var(--ring);background:var(--ghost);color:var(--text);">';
  tagSelectHtml += '<option value="__ALL_TAGS__"'+(currentTagPool==='__ALL_TAGS__'?' selected':'')+'>All tags</option>';
  for(const [name,count] of tagCollections){
    const sel = (currentTagPool === name) ? ' selected' : '';
    tagSelectHtml += '<option value="'+escapeHtml(name)+'"'+sel+'>'+
      escapeHtml(name)+' ('+count+')</option>';
  }
  tagSelectHtml += '</select>';
  tagSelectHtml += '</div>';

  tagSelectHtml += '<div style="display:flex;align-items:center;gap:6px;flex-wrap:wrap;">';
  tagSelectHtml += '<span class="smallMuted">Filter:</span>';
  tagSelectHtml += '<select id="tOtherPoolSelect" style="font-size:13px;padding:4px 6px;border-radius:8px;border:1px solid var(--ring);background:var(--ghost);color:var(--text);">';
  tagSelectHtml += '<option value="__ALL__"'+(currentOtherPool==='__ALL__'?' selected':'')+'>All images</option>';
  tagSelectHtml += '<option value="__RECENT_256__"'+(currentOtherPool==='__RECENT_256__'?' selected':'')+'>Most recent 256 ('+recentCount+')</option>';
  tagSelectHtml += '<optgroup label="Tournament history">';
  tagSelectHtml += '<option value="__NEVER_TOURNEY__"'+(currentOtherPool==='__NEVER_TOURNEY__'?' selected':'')+'>Never in a tournament ('+neverTourneyCount+')</option>';
  tagSelectHtml += '<option value="__FEWEST_TOURNEYS__"'+(currentOtherPool==='__FEWEST_TOURNEYS__'?' selected':'')+'>Fewest tournaments (min '+(Number.isFinite(minTourneyCount) ? minTourneyCount : 0)+', '+fewestTourneyCount+')</option>';
  tagSelectHtml += '</optgroup>';

  if(topPools.length){
    tagSelectHtml += '<optgroup label="Top performers">';
    for(const opt of topPools){
      const sel = (currentOtherPool === opt.value) ? ' selected' : '';
      tagSelectHtml += '<option value="'+opt.value+'"'+sel+'>'+escapeHtml(opt.label)+' ('+opt.count+')</option>';
    }
    tagSelectHtml += '</optgroup>';
  }

  tagSelectHtml += '<optgroup label="Targeted pools">';
  tagSelectHtml += '<option value="'+specialPoolValue+'"'+(currentOtherPool===specialPoolValue?' selected':'')+'>Top 25% win% &amp; bottom 50% matchups ('+specialPoolCount+')</option>';
  tagSelectHtml += '</optgroup>';
  tagSelectHtml += '</select>';
  tagSelectHtml += '</div>';
  tagSelectHtml += '</div>';

  controlsEl.innerHTML =
    fieldSizeHtml +
    poolModeHtml +
    poolSelectHtml +
    tagSelectHtml +
    '<button class="btn" id="tStartBtn">Start new tournament</button>';

  const poolModeInputs = Array.from(document.querySelectorAll('input[name="tPoolMode"]'));
  const poolSelect = document.getElementById('tPoolSelect');
  const tagSelect = document.getElementById('tTagPoolSelect');
  const otherSelect = document.getElementById('tOtherPoolSelect');
  const fieldSizeSelect = document.getElementById('tFieldSizeSelect');
  const startBtn = document.getElementById('tStartBtn');
  const dualControls = document.getElementById('tDualPoolControls');
  const singleControls = poolSelect && poolSelect.parentElement;

  const updatePoolModeUI = ()=>{
    const isDual = currentPoolMode === 'dual';
    if(dualControls) dualControls.style.display = isDual ? 'flex' : 'none';
    if(singleControls) singleControls.style.display = isDual ? 'none' : 'flex';
  };

  const updatePoolSummary = ()=>{
    let count = 0;
    let summary = '';
    if(currentPoolMode === 'dual'){
      const tagLabel = describeTagPool(currentTagPool || '__ALL_TAGS__');
      const otherLabel = describePool(currentOtherPool || '__ALL__');
      const tagItems = applyTagPoolFilter(items, currentTagPool || '__ALL_TAGS__');
      count = applyPoolFilter(tagItems, currentOtherPool || '__ALL__').length;
      summary = 'Selected filters: Tag: ' + escapeHtml(tagLabel) + ' ‚Ä¢ Filter: ' + escapeHtml(otherLabel);
    }else{
      count = applyPoolFilter(items, currentPool || '__ALL__').length;
      const poolLabel = describePool(currentPool || '__ALL__');
      summary = 'Selected pool: ' + escapeHtml(poolLabel);
    }
    hintEl.innerHTML = baseHint + '<br><span class="smallMuted">' +
      summary + ' (' + count + ' images).</span>';
    if(startBtn){
      startBtn.disabled = count < 2;
      startBtn.title = count < 2 ? 'Select a pool with at least 2 images.' : '';
    }
  };
  const updateOtherPoolOptions = ()=>{
    if(!otherSelect) return;
    const tagItems = applyTagPoolFilter(items, currentTagPool || '__ALL_TAGS__');
    const tagRecentCount = applyPoolFilter(tagItems, '__RECENT_256__').length;
    const tagNeverTourneyCount = tagItems.filter(it => Number(it.tourneyCount || 0) === 0).length;
    const tagMinTourneyCount = tagItems.reduce((min, it)=> Math.min(min, Number(it.tourneyCount || 0)), Infinity);
    const tagFewestTourneyCount = Number.isFinite(tagMinTourneyCount)
      ? tagItems.filter(it => Number(it.tourneyCount || 0) === tagMinTourneyCount).length
      : 0;
    const tagTopPools = buildTopPoolOptions(tagItems);
    const tagSpecialPoolCount = applyPoolFilter(tagItems, specialPoolValue).length;

    let html = '';
    html += '<option value="__ALL__"'+(currentOtherPool==='__ALL__'?' selected':'')+'>All images</option>';
    html += '<option value="__RECENT_256__"'+(currentOtherPool==='__RECENT_256__'?' selected':'')+'>Most recent 256 ('+tagRecentCount+')</option>';
    html += '<optgroup label="Tournament history">';
    html += '<option value="__NEVER_TOURNEY__"'+(currentOtherPool==='__NEVER_TOURNEY__'?' selected':'')+'>Never in a tournament ('+tagNeverTourneyCount+')</option>';
    html += '<option value="__FEWEST_TOURNEYS__"'+(currentOtherPool==='__FEWEST_TOURNEYS__'?' selected':'')+'>Fewest tournaments (min '+(Number.isFinite(tagMinTourneyCount) ? tagMinTourneyCount : 0)+', '+tagFewestTourneyCount+')</option>';
    html += '</optgroup>';

    if(tagTopPools.length){
      html += '<optgroup label="Top performers">';
      for(const opt of tagTopPools){
        const sel = (currentOtherPool === opt.value) ? ' selected' : '';
        html += '<option value="'+opt.value+'"'+sel+'>'+escapeHtml(opt.label)+' ('+opt.count+')</option>';
      }
      html += '</optgroup>';
    }

    html += '<optgroup label="Targeted pools">';
    html += '<option value="'+specialPoolValue+'"'+(currentOtherPool===specialPoolValue?' selected':'')+'>Top 25% win% &amp; bottom 50% matchups ('+tagSpecialPoolCount+')</option>';
    html += '</optgroup>';
    otherSelect.innerHTML = html;
  };
  if(poolModeInputs.length){
    for(const input of poolModeInputs){
      input.addEventListener('change', (e)=>{
        currentPoolMode = e.target.value === 'dual' ? 'dual' : 'single';
        updatePoolModeUI();
        updatePoolSummary();
      });
    }
  }
  if(poolSelect){
    poolSelect.addEventListener('change', (e)=>{
      const val = e.target.value || '__ALL__';
      currentPool = val;
      updatePoolSummary();
    });
  }
  if(tagSelect){
    tagSelect.addEventListener('change', (e)=>{
      const val = e.target.value || '__ALL_TAGS__';
      currentTagPool = val;
      updateOtherPoolOptions();
      updatePoolSummary();
    });
  }
  updateOtherPoolOptions();
  if(otherSelect){
    otherSelect.addEventListener('change', (e)=>{
      const val = e.target.value || '__ALL__';
      currentOtherPool = val;
      updatePoolSummary();
    });
  }

  updatePoolModeUI();
  updatePoolSummary();
  if(fieldSizeSelect){
    fieldSizeSelect.addEventListener('change', (e)=>{
      const nextSize = Number(e.target.value) || 256;
      if(nextSize !== currentMaxFieldSize){
        currentMaxFieldSize = nextSize;
        renderAll();
      }
    });
  }
  if(startBtn) addTap(startBtn, startNewTournament);

  return;
}


const s = tourneyState;
const initialSize = s.initialSize;
const size = s.currentRoundSize;
const matchIndex = s.currentMatchIndex;
const totalMatchesThisRound = size/2;

let poolLabel = '';
if(s.poolMode === 'dual'){
  const tagLabel = describeTagPool(s.poolTag || '__ALL_TAGS__');
  const otherLabel = describePool(s.poolOther || '__ALL__');
  poolLabel = ' ‚Ä¢ Pool: Tag: '+tagLabel+' + Filter: '+otherLabel;
}else if(s.pool){
  poolLabel = ' ‚Ä¢ Pool: '+describePool(s.pool);
}

const fieldInfo = 'Field: '+initialSize+' images' + poolLabel;


      const hasHistory = Array.isArray(s.matchHistory) && s.matchHistory.length > 0;

      if(s.completed){
        const champ = itemsById.get(s.championId);
        maybeHydrateFullImage(champ);
        statusEl.textContent = 'Tournament complete.';
        hintEl.textContent = fieldInfo;

        controlsEl.innerHTML =
          (hasHistory ? '<button class="btn" id="tUndoBtn">Undo last result</button> ' : '') +
          '<button class="btn" id="tNewBtn">Start new tournament</button>' +
          ' <button class="btn ghost" id="tResetBtn">Reset / clear</button>';
        const newBtn = document.getElementById('tNewBtn');
        const resetBtn = document.getElementById('tResetBtn');
        const undoBtn = document.getElementById('tUndoBtn');
        if(newBtn) addTap(newBtn, startNewTournament);
        if(resetBtn) addTap(resetBtn, resetTournament);
        if(undoBtn) addTap(undoBtn, undoLastResult);

        if(!champ){
          matchEl.innerHTML = '<div class="hint">Champion image could not be found (may have been deleted).</div>';
        }else{
          const m = matchupsCount(champ);
          const pts = computePoints(champ.wins,champ.losses,champ.tourneyBonus||0);
          const winPct = pct(champ.wins,champ.losses);

          matchEl.innerHTML =
            '<div class="champCard">' +
'<div class="champImgWrap">' +
  '<img id="tChampImg" src="'+getDisplaySrc(champ)+'" data-srcs="'+escapeHtml(serializeSources(getDisplaySources(champ)))+'" data-full-srcs="'+escapeHtml(serializeSources(dedupeSources([...getFullOnlySources(champ), ...getThumbOnlySources(champ)])))+'" data-src-index="0" alt="Champion" />' +
  '<div class="toolbar" style="margin-top:8px;justify-content:center;">' +
    '<button class="btn ghost sm" data-hd-target="tChampImg">Load HD</button>' +
  '</div>' +
'</div>' +

              '<div>' +
                '<div class="champMetaTitle">üèÜ Tournament Champion</div>' +
                '<div class="champMetaLine">'+(formatDisplayTitle(champ.title) || 'Untitled image')+'</div>' +
                '<div class="champMetaLine">W '+champ.wins+' ‚Ä¢ L '+champ.losses+' ‚Ä¢ M '+m+'</div>' +
                '<div class="champMetaLine">Win% '+winPct.toFixed(3)+' ‚Ä¢ Points '+pts+'</div>' +
                '<div class="champMetaLine">Tournament bonus: '+(champ.tourneyBonus||0)+'</div>' +
                '<div class="champMetaLine">Started: '+formatDate(s.createdAt)+'</div>' +
              '</div>' +
            '</div>';
          attachImageFallbacks(matchEl);
          attachHdButtons(matchEl);
        }

        renderBracket();
        return;
      }

      const entrants = getEntrantsForRound(size,s);
      const currentMatch = matchIndex + 1;

      statusEl.textContent =
        roundLabel(size) + ' ‚Ä¢ Match ' + currentMatch + ' of ' + totalMatchesThisRound;
      hintEl.textContent = fieldInfo;

      controlsEl.innerHTML =
        (hasHistory ? '<button class="btn" id="tUndoBtn">Undo last result</button> ' : '') +
        '<button class="btn" id="tNewBtn">New tournament</button>' +
        ' <button class="btn ghost" id="tResetBtn">Reset / clear</button>';
      const newBtn = document.getElementById('tNewBtn');
      const resetBtn = document.getElementById('tResetBtn');
      const undoBtn = document.getElementById('tUndoBtn');
      if(newBtn) addTap(newBtn, startNewTournament);
      if(resetBtn) addTap(resetBtn, resetTournament);
      if(undoBtn) addTap(undoBtn, undoLastResult);

      if(entrants.length < size){
        matchEl.innerHTML =
          '<div class="hint">Bracket data is inconsistent. You may need to reset the tournament.</div>';
        renderBracket();
        return;
      }

      const idxA = matchIndex * 2;
      const idxB = idxA + 1;
      const idA = entrants[idxA];
      const idB = entrants[idxB];
      const left = itemsById.get(idA);
      const right = itemsById.get(idB);
      maybeHydrateFullImage(left);
      maybeHydrateFullImage(right);

      if(!left || !right){
        matchEl.innerHTML =
          '<div class="hint">One or more images are missing. You may need to reset the tournament.</div>';
        renderBracket();
        return;
      }

      const leftPts = computePoints(left.wins,left.losses,left.tourneyBonus||0);
      const rightPts = computePoints(right.wins,right.losses,right.tourneyBonus||0);

      matchEl.innerHTML =
'<div class="arena">' +
  '<button class="imageCardBtn" id="tLeftImgBtn">' +
    '<div class="imageCard">' +
      '<img id="tLeftImg" src="'+getDisplaySrc(left)+'" data-srcs="'+escapeHtml(serializeSources(getDisplaySources(left)))+'" data-full-srcs="'+escapeHtml(serializeSources(dedupeSources([...getFullOnlySources(left), ...getThumbOnlySources(left)])))+'" data-src-index="0" alt="Left" />' +
    '</div>' +
  '</button>' +
  '<div class="vs">VS</div>' +
  '<button class="imageCardBtn" id="tRightImgBtn">' +
    '<div class="imageCard">' +
      '<img id="tRightImg" src="'+getDisplaySrc(right)+'" data-srcs="'+escapeHtml(serializeSources(getDisplaySources(right)))+'" data-full-srcs="'+escapeHtml(serializeSources(dedupeSources([...getFullOnlySources(right), ...getThumbOnlySources(right)])))+'" data-src-index="0" alt="Right" />' +
    '</div>' +
  '</button>' +
'</div>' +

        '<div class="matchMetaRow">' +
          '<div class="matchMetaBox">' +
            '<div class="matchMetaTitle">Left image</div>' +
            '<div class="matchMetaStats">' +
              (formatDisplayTitle(left.title) || 'Untitled') + '<br/>' +
              'W '+left.wins+' ‚Ä¢ L '+left.losses+' ‚Ä¢ Pts '+leftPts+' ‚Ä¢ M '+matchupsCount(left) +
            '</div>' +
            '<div class="toolbar" style="margin-top:4px;justify-content:flex-start;">' +
              '<button class="btn ghost sm" data-hd-target="tLeftImg">Load HD</button>' +
            '</div>' +
          '</div>' +
          '<div></div>' +
          '<div class="matchMetaBox">' +
            '<div class="matchMetaTitle">Right image</div>' +
            '<div class="matchMetaStats">' +
              (formatDisplayTitle(right.title) || 'Untitled') + '<br/>' +
              'W '+right.wins+' ‚Ä¢ L '+right.losses+' ‚Ä¢ Pts '+rightPts+' ‚Ä¢ M '+matchupsCount(right) +
            '</div>' +
            '<div class="toolbar" style="margin-top:4px;justify-content:flex-start;">' +
              '<button class="btn ghost sm" data-hd-target="tRightImg">Load HD</button>' +
            '</div>' +
          '</div>' +
        '</div>' +
        '<div class="matchFooter">' +
          '<button class="btn sm" id="tLeftWinBtn">Left wins</button>' +
          '<button class="btn sm" id="tRightWinBtn">Right wins</button>' +
        '</div>';
      attachImageFallbacks(matchEl);
      attachHdButtons(matchEl);

      const leftImgBtn = document.getElementById('tLeftImgBtn');
      const rightImgBtn = document.getElementById('tRightImgBtn');
      const leftWinBtn = document.getElementById('tLeftWinBtn');
      const rightWinBtn = document.getElementById('tRightWinBtn');

      // Images: click only (allow scroll/zoom)
      if(leftImgBtn){
        leftImgBtn.addEventListener('click', (e)=>{
          e.preventDefault();
          pickWinner('left');
        });
      }
      if(rightImgBtn){
        rightImgBtn.addEventListener('click', (e)=>{
          e.preventDefault();
          pickWinner('right');
        });
      }

      // Buttons: full tap helper
      addTap(leftWinBtn, ()=>pickWinner('left'));
      addTap(rightWinBtn, ()=>pickWinner('right'));

      renderBracket();
    }

    function renderBracket(){
      bracketEl.innerHTML = '';

      if(!tourneyState) return;

      const s = tourneyState;
      const initialSize = s.initialSize;

      // Show bracket from Sweet 16 onward
      if(!s.completed && s.currentRoundSize > 16) return;

      const sizes = [16,8,4,2].filter(sz => sz <= initialSize);
      if(sizes.length === 0) return;

      let html = '';
      html += '<div class="smallMuted" style="margin-bottom:6px;">Bracket (Sweet 16 onward)</div>';
      html += '<div class="tBracket">';

      for(const sz of sizes){
        const entrants = getEntrantsForRound(sz,s);
        const winners = (s.bracketProgress && s.bracketProgress[String(sz)]) || [];
        const roundsMatches = Math.floor(entrants.length / 2);

        html += '<div class="tRoundCol">';
        html += '<div class="tRoundTitle">'+roundLabel(sz)+'</div>';

        if(roundsMatches === 0){
          html += '<div class="smallMuted">TBD</div>';
        }else{
          for(let i=0;i<roundsMatches;i++){
            const aId = entrants[i*2];
            const bId = entrants[i*2+1];
            const winnerId = winners[i];
            const aName = shortLabelForId(aId);
            const bName = shortLabelForId(bId);
            const aClass = 'tSlot' + (winnerId === aId ? ' tWinner' : '');
            const bClass = 'tSlot' + (winnerId === bId ? ' tWinner' : '');
            html += '<div class="tMatchPair">';
            html += '<div class="'+aClass+'">'+aName+'</div>';
            html += '<div class="'+bClass+'">'+bName+'</div>';
            html += '</div>';
          }
        }

        html += '</div>';
      }

      html += '</div>';

      bracketEl.innerHTML = html;
    }

async function startNewTournament(){
  if(items.length < 2){
    alert('You need at least 2 images to run a tournament.');
    return;
  }
  const modeInput = document.querySelector('input[name="tPoolMode"]:checked');
  if(modeInput){
    currentPoolMode = modeInput.value === 'dual' ? 'dual' : 'single';
  }
  const poolSelect = document.getElementById('tPoolSelect');
  if(poolSelect){
    currentPool = poolSelect.value || '__ALL__';
  }
  const tagSelect = document.getElementById('tTagPoolSelect');
  if(tagSelect){
    currentTagPool = tagSelect.value || '__ALL_TAGS__';
  }
  const otherSelect = document.getElementById('tOtherPoolSelect');
  if(otherSelect){
    currentOtherPool = otherSelect.value || '__ALL__';
  }
  const fieldSizeSelect = document.getElementById('tFieldSizeSelect');
  if(fieldSizeSelect){
    currentMaxFieldSize = Number(fieldSizeSelect.value) || 256;
  }
  if(tourneyState && !confirm('Start a new tournament? This will overwrite the current tournament progress.')){
    return;
  }

  // Decide which images to use based on the selected pool
  let poolItems = [];
  let poolLabel = '';
  if(currentPoolMode === 'dual'){
    const tagLabel = describeTagPool(currentTagPool || '__ALL_TAGS__');
    const otherLabel = describePool(currentOtherPool || '__ALL__');
    const tagItems = applyTagPoolFilter(items, currentTagPool || '__ALL_TAGS__');
    poolItems = applyPoolFilter(tagItems, currentOtherPool || '__ALL__');
    poolLabel = 'Tag: '+tagLabel+' + Filter: '+otherLabel;
  }else{
    poolItems = applyPoolFilter(items, currentPool || '__ALL__');
    poolLabel = describePool(currentPool || '__ALL__');
  }

  if(poolItems.length < 2){
    alert('Not enough images in the selected pool to run a tournament.');
    return;
  }

  const ids = poolItems.map(it=>it.id);
  for(let i=ids.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [ids[i],ids[j]] = [ids[j],ids[i]];
  }

  let initialSize = Math.min(currentMaxFieldSize, ids.length);
  let pow = 1;
  while(pow*2 <= initialSize){ pow *= 2; }
  initialSize = Math.max(2, pow);

  const participantIds = ids.slice(0,initialSize);

  // NEW: bump tourneyCount once for everyone in this field
  try{
    await incrementTourneyCountsForParticipants(participantIds);
  }catch(e){
    console.error('Failed to increment tourney counts', e);
  }

  tourneyState = {
    id: TOURNEY_STATE_ID,
    createdAt: new Date().toISOString(),
    initialSize,
    currentRoundSize: initialSize,
    currentMatchIndex: 0,
    participantIds,
    bracketProgress: {},
    completed: false,
    championId: null,
    matchHistory: [],
    pool: currentPoolMode === 'single' ? (currentPool || '__ALL__') : null,
    poolMode: currentPoolMode,
    poolTag: currentPoolMode === 'dual' ? (currentTagPool || '__ALL_TAGS__') : null,
    poolOther: currentPoolMode === 'dual' ? (currentOtherPool || '__ALL__') : null,
    poolLabel
  };

  try{
    await saveTourneyState(tourneyState);
  }catch(e){
    console.error(e);
  }
  renderAll();
}


    async function resetTournament(){
      if(!confirm('Clear tournament state? This does not affect image stats or points.')){
        return;
      }
      try{
        await clearTourneyState();
      }catch(e){
        console.error(e);
      }
      tourneyState = null;
      renderAll();
    }

    async function applyWinLoss(winnerId, loserId){
      const w = itemsById.get(winnerId);
      const l = itemsById.get(loserId);
      if(w){
        w.wins = Math.max(0, (w.wins||0) + 1);
        if(typeof w.tourneyBonus !== 'number') w.tourneyBonus = Number(w.tourneyBonus||0);
        try{ await idbPutItem(w); }catch(e){ console.error(e); }
      }
      if(l){
        l.losses = Math.max(0, (l.losses||0) + 1);
        if(typeof l.tourneyBonus !== 'number') l.tourneyBonus = Number(l.tourneyBonus||0);
        try{ await idbPutItem(l); }catch(e){ console.error(e); }
      }
    }

    async function reverseWinLoss(winnerId, loserId){
      const w = itemsById.get(winnerId);
      const l = itemsById.get(loserId);
      if(w){
        w.wins = Math.max(0, (w.wins||0) - 1);
        try{ await idbPutItem(w); }catch(e){ console.error(e); }
      }
      if(l){
        l.losses = Math.max(0, (l.losses||0) - 1);
        try{ await idbPutItem(l); }catch(e){ console.error(e); }
      }
    }

async function incrementTourneyCountsForParticipants(participantIds){
  if (!Array.isArray(participantIds) || !participantIds.length) return;

  for (const id of participantIds){
    const item = itemsById.get(id);
    if (!item) continue;

    // bump in-memory
    const prev = Number(item.tourneyCount || 0);
    item.tourneyCount = prev + 1;

    // persist to main items DB
    try{
      await idbPutItem(item);
    }catch(e){
      console.error('Failed to bump tourneyCount for', id, e);
    }
  }
}

    async function applyChampionBonus(championId){
      const champ = itemsById.get(championId);
      if(!champ) return;
      const prev = Number(champ.tourneyBonus || 0);
      champ.tourneyBonus = prev + 5;
      try{
        await idbPutItem(champ);
      }catch(e){
        console.error(e);
      }
    }

    async function removeChampionBonus(championId){
      const champ = itemsById.get(championId);
      if(!champ) return;
      const prev = Number(champ.tourneyBonus || 0);
      champ.tourneyBonus = Math.max(0, prev - 5);
      try{
        await idbPutItem(champ);
      }catch(e){
        console.error(e);
      }
    }

    async function pickWinner(side){
      if(isProcessing) return;
      if(!tourneyState || tourneyState.completed) return;
      isProcessing = true;

      try{
        const s = tourneyState;
        const size = s.currentRoundSize;
        const entrants = getEntrantsForRound(size,s);
        if(entrants.length < size){
          alert('Bracket data is inconsistent. Please reset the tournament.');
          isProcessing = false;
          return;
        }

        const idxA = s.currentMatchIndex * 2;
        const idxB = idxA + 1;
        const idA = entrants[idxA];
        const idB = entrants[idxB];
        if(!idA || !idB){
          alert('Match data is incomplete. Please reset the tournament.');
          isProcessing = false;
          return;
        }

        const winnerId = (side === 'left') ? idA : idB;
        const loserId = (side === 'left') ? idB : idA;

        await applyWinLoss(winnerId, loserId);

        // record history
        if(!Array.isArray(s.matchHistory)) s.matchHistory = [];
        s.matchHistory.push({
          roundSize: size,
          winnerId,
          loserId
        });

        const key = String(size);
        if(!s.bracketProgress) s.bracketProgress = {};
        if(!Array.isArray(s.bracketProgress[key])) s.bracketProgress[key] = [];
        s.bracketProgress[key].push(winnerId);
        s.currentMatchIndex += 1;

        const finishedRound = s.currentMatchIndex >= size/2;

        if(finishedRound){
          if(size === 2){
            s.completed = true;
            s.championId = winnerId;
            await applyChampionBonus(winnerId);
          }else{
            s.currentRoundSize = size/2;
            s.currentMatchIndex = 0;
          }
        }

        await saveTourneyState(s);
        tourneyState = s;
        renderAll();
      }catch(e){
        console.error(e);
      }finally{
        isProcessing = false;
      }
    }

    async function undoLastResult(){
      if(isProcessing) return;
      if(!tourneyState || !Array.isArray(tourneyState.matchHistory) || tourneyState.matchHistory.length === 0){
        alert('No tournament result to undo.');
        return;
      }
      isProcessing = true;

      try{
        const s = tourneyState;
        const last = s.matchHistory[s.matchHistory.length - 1];

        // If the tournament was completed and this last match was the championship, remove bonus
        const wasCompleted = s.completed;
        const wasChampionMatch = (last.roundSize === 2 && s.championId === last.winnerId);

        // Reverse stats
        await reverseWinLoss(last.winnerId, last.loserId);
        if(wasCompleted && wasChampionMatch){
          await removeChampionBonus(last.winnerId);
        }

        // Pop history entry
        s.matchHistory.pop();

        // Rebuild bracketProgress, round, etc. from remaining history
        const baseState = {
          id: s.id,
          createdAt: s.createdAt,
          initialSize: s.initialSize,
          participantIds: s.participantIds.slice(),
          bracketProgress: {},
          currentRoundSize: s.initialSize,
          currentMatchIndex: 0,
          completed: false,
          championId: null,
          matchHistory: s.matchHistory.slice()
        };

        // replay winners into bracketProgress
        for(const h of baseState.matchHistory){
          const sz = h.roundSize;
          const key = String(sz);
          if(!baseState.bracketProgress[key]) baseState.bracketProgress[key] = [];
          baseState.bracketProgress[key].push(h.winnerId);
        }

        // compute current round / match / completion
        let currentSize = baseState.initialSize;
        while(true){
          const key = String(currentSize);
          const winnersArr = baseState.bracketProgress[key] || [];
          const matchesInRound = currentSize / 2;

          if(winnersArr.length < matchesInRound){
            baseState.currentRoundSize = currentSize;
            baseState.currentMatchIndex = winnersArr.length;
            baseState.completed = false;
            baseState.championId = null;
            break;
          }

          if(currentSize === 2){
            baseState.currentRoundSize = 2;
            baseState.currentMatchIndex = matchesInRound; // 1
            baseState.completed = true;
            baseState.championId = winnersArr[0] || null;
            break;
          }else{
            currentSize = currentSize / 2;
          }
        }

        tourneyState = baseState;
        await saveTourneyState(tourneyState);
        renderAll();
      }catch(e){
        console.error(e);
      }finally{
        isProcessing = false;
      }
    }

    window.addEventListener('load', initTournamentPage);
  </script>
</body>
</html>
