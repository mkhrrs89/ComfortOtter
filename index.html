<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ModelMatchup ‚Äî AI Image Rater</title>
  <meta name="theme-color" content="#050c0a" />
<link rel="stylesheet" href="app-style.css">

  <style>
    :root{
      --bg:#050c0a;
      --panel:#091612;
      --panel-soft:#0e1f1a;
      --muted:#8fb0a1;
      --text:#e7f5ef;
      --accent:#1f9d73;
      --accent-soft:#153e30;
      --danger:#ff5f71;
      --ghost:#182621;
      --ring:#1b3a2f;
      --card:#07100d;
      --border-soft:#123427;
    }
    *{box-sizing:border-box}
    html,body,#root{height:100%}
    body{
      margin:0;
      background:radial-gradient(circle at top,#103828 0,#050c0a 55%);
      color:var(--text);
      font:14px/1.4 system-ui,Segoe UI,Roboto,Arial,sans-serif;
    }
    .app{
      max-width:1180px;
      margin:0 auto;
      padding:16px 20px 40px;
    }
    .header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:16px;
      margin-bottom:10px;
    }
    .titleBlock{
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    h1{
      font-size:22px;
      margin:0;
      letter-spacing:0.03em;
    }
    .tabs{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
    }
    .tab{
      background:var(--panel);
      color:var(--text);
      border:1px solid var(--ring);
      padding:7px 11px;
      border-radius:999px;
      cursor:pointer;
      font-size:13px;
      text-decoration:none;
      display:inline-flex;
      align-items:center;
      justify-content:center;
    }
    .tab.active{
      outline:2px solid var(--accent);
      background:linear-gradient(135deg,#1f9d73,#157457);
    }

.badgeSummary {
  font-size: 14px;
  opacity: 0.85;
  display: grid;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  gap: 8px 16px;
}

.badgeItem {
  display: inline-flex;
  align-items: center;
  gap: 6px;
}

    .pane{
      background:var(--panel);
      border:1px solid var(--ring);
      border-radius:14px;
      padding:14px;
      margin-bottom:14px;
    }
    .toolbar{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      margin-top:8px;
      align-items:center;
    }
    .btn{
      background:var(--accent);
      color:white;
      border:none;
      padding:7px 11px;
      border-radius:10px;
      cursor:pointer;
      font-size:13px;
      display:inline-flex;
      align-items:center;
      gap:6px;
    }
    .btn.sm{padding:5px 9px;font-size:12px}
    .btn.ghost{
      background:var(--ghost);
    }
    .btn.secondary{
      background:linear-gradient(135deg,#1f9d73,#157457);
    }
    .btn.danger{
      background:var(--danger);
    }
    .btn[disabled]{
      opacity:0.5;
      cursor:default;
    }
    .collectionFilterToolbar{
      flex-direction:column;
      align-items:flex-start;
      gap:10px;
    }
    .collectionFilterHeader{
      width:100%;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
      flex-wrap:wrap;
    }
    .collectionGroupsGrid{
      width:100%;
      display:grid;
      grid-template-columns:repeat(auto-fit,minmax(240px,1fr));
      gap:10px;
    }
    .collectionGroupCard{
      background:var(--panel-soft);
      border:1px solid var(--ring);
      border-radius:12px;
      padding:10px;
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .collectionGroupHeader{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
      flex-wrap:wrap;
    }
    .collectionGroupToggle{
      flex:1;
      justify-content:space-between;
    }
    .collectionGroupCaret{
      min-width:34px;
      justify-content:center;
      padding:5px 8px;
    }
    .collectionGroupItems{
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    .collectionGroupItems.generatorList{
      flex-direction:row;
      flex-wrap:wrap;
      align-items:center;
    }
    .collectionGroupRow{
      display:flex;
      align-items:center;
      gap:6px;
      flex-wrap:wrap;
    }
    .collectionGroupSelect{
      min-width:150px;
    }
    .select,
    .input{
      background:#050c0a;
      border:1px solid var(--ring);
      color:var(--text);
      border-radius:8px;
      padding:6px 8px;
      font-size:13px;
    }
    .select{min-width:130px}
    .select.sm{padding:5px 7px;font-size:12px}
    .dropzone{
      border:1.5px dashed var(--ring);
      border-radius:12px;
      padding:24px;
      text-align:center;
      cursor:pointer;
      background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);
    }
    .dropzone p{margin:0;color:var(--muted);font-size:13px}
    .hint{color:var(--muted);padding:12px 0;font-size:13px}
    /* Library standard card grid */
    .grid{
      display:grid;
      grid-template-columns:repeat(auto-fill,minmax(230px,1fr));
      gap:10px;
      list-style:none;
      padding:0;
      margin:0;
    }
    .card{
      border:1px solid var(--border-soft);
      border-radius:12px;
      overflow:hidden;
      background:var(--card);
      display:flex;
      flex-direction:column;
    }
    .cardThumb{
      position:relative;
      background:#000;
    }
    .cardThumb img{
      width:100%;
      height:210px;
      object-fit:cover;
      display:block;
    }
    .cardBody{
      padding:9px;
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    .fieldRow{
      display:flex;
      flex-direction:column;
      gap:3px;
      font-size:12px;
      color:var(--muted);
    }
    .fieldRow label{font-size:11px}
    .fieldRow input{
      background:#050c0a;
      border:1px solid var(--ring);
      color:var(--text);
      padding:6px 7px;
      border-radius:8px;
      font-size:13px;
    }
    .statLine{
      font-size:12px;
      color:var(--muted);
      display:flex;
      flex-wrap:wrap;
      gap:8px;
    }
    .addedAt{
      font-size:11px;
      color:var(--muted);
    }
    /* Matchups */
    .arena{
      display:grid;
      grid-template-columns:1fr auto 1fr;
      align-items:center;
      gap:12px;
      margin:10px 0 6px;
    }
    .imageCard{
      position:relative;
      border:1px solid var(--ring);
      border-radius:14px;
      overflow:hidden;
      cursor:pointer;
      background:#000;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:4px;
    }
    .imageCard.medal-gold{
      border-color:#d4af37;
      box-shadow:0 0 0 1px #d4af37;
    }
    .imageCard.medal-silver{
      border-color:#c0c0c0;
      box-shadow:0 0 0 1px #c0c0c0;
    }
    .imageCard.medal-bronze{
      border-color:#cd7f32;
      box-shadow:0 0 0 1px #cd7f32;
    }
    .imageCard img{
      width:100%;
      height:64vh;
      max-height:520px;
      object-fit:contain;
      background:#000;
      display:block;
    }
    @media (max-width: 768px) and (orientation: portrait) {
      .imageCard img {
        height:48vh;
        max-height:360px;
      }
    }
    .vs{
      font-weight:700;
      opacity:0.8;
      font-size:16px;
    }
    .matchMetaRow{
      display:grid;
      grid-template-columns:1fr auto 1fr;
      gap:12px;
      align-items:center;
      margin-bottom:6px;
      font-size:13px;
    }
    .matchMetaBox{
      background:var(--panel-soft);
      border-radius:10px;
      padding:6px 8px;
      border:1px solid var(--ring);
      display:flex;
      flex-direction:column;
      gap:3px;
    }
    .matchMetaTitle{
      font-size:11px;
      color:var(--muted);
      text-transform:uppercase;
      letter-spacing:0.06em;
    }
    .matchMetaStats{
      font-size:13px;
    }
    .matchRecord{
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding:2px 8px;
      border-radius:999px;
      background:rgba(56,189,248,0.12);
      border:1px solid rgba(56,189,248,0.35);
      font-weight:600;
      font-size:14px;
      margin:2px 0;
    }
    .matchFooter{
      display:flex;
      justify-content:center;
      gap:8px;
      margin-top:4px;
    }
    .matchPoolInfo{
      font-size:12px;
      color:var(--muted);
      margin-top:4px;
      text-align:center;
    }
    /* Tables */
    .statsTab{
      background:var(--panel);
      border:1px solid var(--ring);
      border-radius:14px;
      padding:10px;
    }
    .rankNotice{
      position:fixed;
      left:16px;
      bottom:16px;
      width:320px;
      max-width:85vw;
      background:rgba(9,22,18,0.95);
      border:1px solid var(--ring);
      border-radius:14px;
      box-shadow:0 16px 40px rgba(0,0,0,0.45);
      padding:10px;
      display:flex;
      flex-direction:column;
      gap:8px;
      transform:translateY(140%);
      opacity:0;
      transition:transform 0.4s ease, opacity 0.4s ease;
      z-index:30;
    }
    .rankNotice.show{
      transform:translateY(0);
      opacity:1;
    }
    .rankNoticeList{
      display:flex;
      flex-direction:column;
      gap:8px;
      max-height:320px;
      overflow-y:auto;
    }
    .rankNoticeRow{
      display:flex;
      gap:10px;
      align-items:center;
      background:var(--panel-soft);
      border:1px solid var(--border-soft);
      border-radius:10px;
      padding:6px;
    }
    .rankNoticeThumb{
      width:64px;
      height:64px;
      object-fit:cover;
      border-radius:8px;
      border:1px solid var(--ring);
      background:var(--card);
      flex-shrink:0;
    }
    .rankNoticeText{
      font-size:12px;
      color:var(--text);
      line-height:1.3;
    }
    table{
      width:100%;
      border-collapse:collapse;
      font-size:12px;
    }
    th,td{
      border-bottom:1px solid var(--border-soft);
      padding:6px 5px;
      text-align:left;
    }
    th{
      font-size:11px;
      color:var(--muted);
      user-select:none;
      cursor:pointer;
      white-space:nowrap;
    }
/* Mobile tweaks for Stats table */
@media (max-width: 768px){
  .statsTab{
    padding:8px;
    overflow-x:auto;
    -webkit-overflow-scrolling:touch; /* smooth scroll on iOS */
  }
  .statsTab table{
    min-width: 720px; /* keep columns readable, horizontal scroll if needed */
  }
}
    th.sortable:hover{
      background:rgba(255,255,255,0.03);
    }
    th .sort-ind{
      font-size:10px;
      opacity:0.8;
      margin-left:3px;
    }
    .thumbWrap{
      position:relative;
      display:inline-block;
    }
    .thumb{
      width:46px;
      height:46px;
      object-fit:cover;
      border-radius:8px;
      border:1px solid var(--ring);
      cursor:pointer;
      background:#000;
      display:block;
    }
    /* Modals */
    .modal{
      position:fixed;
      top:0;
      right:0;
      bottom:0;
      left:0;
      background:rgba(0,0,0,0.78);
      display:flex;
      align-items:center;
      justify-content:center;
      padding:20px;
      z-index:1000;
      width:100vw;
      height:100vh;
      overflow-y:auto;
      overscroll-behavior:contain;
    }
.modalInner{
  background:#050c0a;
  border:1px solid var(--ring);
  border-radius:12px;
  max-width:96vw;
  max-height:96vh;
  padding:12px;
  display:flex;
  flex-direction:column;
  gap:10px;
  overflow-y:auto;           /* üëà NEW: allow scrolling inside the modal */
}

    @supports (height: 100dvh){
      .modal{
        height:100dvh;
      }
      .modalInner{
        max-height:96dvh;
      }
    }

    @media (max-width: 900px) and (orientation: landscape){
      .modal{
        padding:12px;
      }
      .modalInner{
        max-height:calc(100vh - 24px);
      }
      @supports (height: 100dvh){
        .modalInner{
          max-height:calc(100dvh - 24px);
        }
      }
    }

    .previewImgWrap{
      position:relative;
      max-width:92vw;
      max-height:70vh;
      margin:0 auto;
    }
    .previewImgWrap img{
      max-width:100%;
      max-height:70vh;
      display:block;
      margin:0 auto;
      border-radius:10px;
    }

@media (max-width: 700px){
  .previewImgWrap,
  .previewImgWrap img{
    max-height:60vh;   /* slightly smaller image on small screens */
  }
}

    .modalFields{
      display:grid;
      grid-template-columns:repeat(auto-fit,minmax(160px,1fr));
      gap:8px;
      font-size:12px;
      color:var(--muted);
    }
    .modalFields input{
      width:100%;
      background:#050c0a;
      border:1px solid var(--ring);
      color:var(--text);
      border-radius:8px;
      padding:6px 7px;
      font-size:13px;
    }
    .statEditGrid{
      display:grid;
      grid-template-columns:repeat(auto-fit,minmax(140px,1fr));
      gap:8px;
    }
    .statEditGrid label{
      display:flex;
      flex-direction:column;
      gap:4px;
      color:var(--muted);
      font-size:11px;
    }
    .statEditGrid input{
      width:100%;
      background:#050c0a;
      border:1px solid var(--ring);
      color:var(--text);
      border-radius:8px;
      padding:6px 7px;
      font-size:13px;
    }
    @media (hover: none) and (pointer: coarse){
      .modalFields input,
      .modalFields select{
        font-size:16px;
      }
    }
    .modalFooter{
      display:flex;
      justify-content:center;
      gap:8px;
    }
    /* Cropper */
    .cropCanvas{
      max-width:86vw;
      max-height:70vh;
      border:1px solid var(--ring);
      border-radius:10px;
      background:#000;
      touch-action:none;
    }
    .cropHint{
      color:var(--muted);
      font-size:12px;
      text-align:center;
    }
    /* Gallery view */
    .galleryControls{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      margin-bottom:8px;
      align-items:center;
      justify-content:space-between;
    }
    .galleryGrid{
      display:grid;
      grid-template-columns:repeat(4,minmax(0,1fr));
      gap:8px;
    }
    @media (max-width:900px){
      .galleryGrid{grid-template-columns:repeat(3,minmax(0,1fr));}
    }
    @media (max-width:700px){
      .galleryGrid{grid-template-columns:repeat(2,minmax(0,1fr));}
    }
    @media (max-width:480px){
      .galleryGrid{grid-template-columns:repeat(1,minmax(0,1fr));}
    }
    .galleryItem{
      position:relative;
      cursor:pointer;
    }
    .galleryImg{
      width:100%;
      height:auto;
      display:block;
      border-radius:10px;
      border:1px solid var(--border-soft);
      background:#000;
    }
    .galleryOverlay{
      position:absolute;
      inset:0;
      pointer-events:none;
      border-radius:10px;
      box-shadow:0 0 0 1px rgba(255,255,255,0.05);
    }
    .galleryMeta{
      position:absolute;
      left:6px;
      bottom:5px;
      right:6px;
      display:flex;
      justify-content:flex-end;
      align-items:flex-end;
      gap:6px;
    }
    .galleryCheckWrap{
      background:rgba(0,0,0,0.7);
      border-radius:999px;
      padding:3px 6px;
      display:flex;
      align-items:center;
      gap:4px;
    }
    .checkbox{
      width:14px;
      height:14px;
      border-radius:4px;
      border:1px solid #c5f4d8;
      background:rgba(0,0,0,0.4);
      display:inline-block;
      position:relative;
    }
    .checkbox.checked::after{
      content:'';
      position:absolute;
      inset:2px;
      border-radius:3px;
      background:#3ee69d;
    }
    .smallMuted{
      font-size:11px;
      color:var(--muted);
    }
    .pill{
      border-radius:999px;
      padding:2px 7px;
      font-size:11px;
      background:var(--accent-soft);
      border:1px solid var(--ring);
      color:#c5f4dc;
    }
    .flexRow{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      align-items:center;
    }
    .pager{
      display:flex;
      justify-content:space-between;
      align-items:center;
      margin-top:8px;
      font-size:12px;
      color:var(--muted);
      flex-wrap:wrap;
      gap:8px;
    }
    /* BADGES */
    .badgeRow{
      display:flex;
      gap:4px;
      align-items:center;
      font-size:11px;
      line-height:1;
    }
    .badgeRow-top-right{
      position:absolute;
      top:5px;
      right:5px;
      z-index:3;
    }
    .badgeRow-inline{
      display:flex;
      gap:4px;
      align-items:center;
    }
    .badge{
      border-radius:999px;
      padding:2px 5px;
      font-size:11px;
      line-height:1.1;
      background:rgba(0,0,0,0.7);
      border:1px solid rgba(255,255,255,0.18);
      display:inline-flex;
      align-items:center;
      justify-content:center;
    }
    .badgeRow-top-right .badge{
      padding:3px 7px;
      font-size:13px;
      box-shadow:0 0 6px rgba(0,0,0,0.6);
    }
    .badge.gold{
      background:linear-gradient(135deg,#fce38a,#f5a623);
      border-color:#f8d35a;
      color:#251a03;
    }
    .badge.silver{
      background:linear-gradient(135deg,#e6ecf6,#aab2c4);
      border-color:#c0c7d1;
      color:#111726;
    }
    .badge.bronze{
      background:linear-gradient(135deg,#f4c28a,#c8753a);
      border-color:#d18b5a;
      color:#2b1708;
    }
    .badge.fresh{
      background:linear-gradient(135deg,#a7f8cd,#35c47a);
      border-color:#61e0a0;
      color:#042514;
    }
    .badge.undefeated{
      background:linear-gradient(135deg,#fff8b3,#ffd54f);
      border-color:#ffe082;
      color:#3b2a00;
    }
    .badge.winless{
      background:linear-gradient(135deg,#3b1a1a,#8d4b3a);
      border-color:#b36a50;
      color:#ffe7d8;
    }
  </style>
</head>
<body>
  <div id="root"></div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-app.js";
  import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-auth.js";
  import { getFirestore, doc, setDoc } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore.js";
  import { getStorage, ref, uploadString, getDownloadURL } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-storage.js";

  // Comforting Otter config
  const firebaseConfig = {
    apiKey: "AIzaSyBOVGz7QH_iPtxoM25baGqTIR-2yxUQwH8",
    authDomain: "comforting-otter.firebaseapp.com",
    projectId: "comforting-otter",
    storageBucket: "comforting-otter.firebasestorage.app",
    messagingSenderId: "1074346290690",
    appId: "1:1074346290690:web:bd2721e73fbdf029e7411b",
    measurementId: "G-2JT31JFGNJ"
  };

  const app     = initializeApp(firebaseConfig);
  const auth    = getAuth(app);
  const db      = getFirestore(app);
  const storage = getStorage(app);

  // --- AUTH ---

  signInAnonymously(auth).catch(err => {
    console.error("Anonymous sign-in failed:", err);
  });

  onAuthStateChanged(auth, user => {
    if (user) {
      console.log("‚úÖ Firebase ready. Anonymous UID:", user.uid);
    } else {
      console.log("‚ÑπÔ∏è Not signed in yet");
    }
  });

  // --- METADATA MIRRORING ---

  // Remove heavy fields before sending to Firestore
  function stripBigFields(item) {
    if (!item || !item.id) return null;

    const {
      dataUrl,
      thumbnail,
      thumbDataUrl,
      // future big fields can be stripped here
      ...rest
    } = item;

    return {
      ...rest,
      updatedAt: new Date().toISOString()
    };
  }

  async function saveItemToCloud(item) {
    const meta = stripBigFields(item);
    if (!meta) return;

    try {
      const ref = doc(db, "images", meta.id); // one doc per image
      await setDoc(ref, meta, { merge: true });
      // console.log("‚òÅÔ∏è mirrored to Firestore", meta.id);
    } catch (err) {
      console.error("Cloud save failed for", meta && meta.id, err);
      // don't throw ‚Äì local save should still succeed
    }
  }

  // Expose to the rest of your app
  window.firebaseApp     = app;
  window.firebaseAuth    = auth;
  window.firebaseDb      = db;
  window.firebaseStorage = storage;
  window.uploadDataUrlToFirebase = async function uploadDataUrlToFirebase(id, dataUrl){
    if(!id || !dataUrl) return null;
    try{
      const path = `images/${id}.jpg`;
      const storageRef = ref(storage, path);
      await uploadString(storageRef, dataUrl, 'data_url');
      const fullUrl = await getDownloadURL(storageRef);
      return fullUrl;
    }catch(err){
      console.error('Upload failed for cropped image', err);
      return null;
    }
  };
  window.fetchFullImageUrl = async function fetchFullImageUrl(id){
    if(!id) return null;
    try{
      const storageRef = ref(storage, `images/${id}.jpg`);
      return await getDownloadURL(storageRef);
    }catch(err){
      console.warn('Full image URL unavailable from Firebase', err);
      return null;
    }
  };
  window.saveItemToCloud = saveItemToCloud;
</script>



<!-- React + Babel (ONE copy). data-cfasync disables Cloudflare Rocket Loader interference. -->
<script data-cfasync="false">
  window.__fail = (label, src) => {
    const msg = `FAILED TO LOAD SCRIPT:\n${label}\n${src}`;
    console.error(msg);
    alert(msg);
  };
</script>
<script data-cfasync="false" crossorigin="anonymous"
  src="https://cdn.jsdelivr.net/npm/react@18/umd/react.production.min.js"
  onerror="__fail('React failed to load', this.src)"></script>
<script data-cfasync="false" crossorigin="anonymous"
  src="https://cdn.jsdelivr.net/npm/react-dom@18/umd/react-dom.production.min.js"
  onerror="__fail('ReactDOM failed to load', this.src)"></script>
<script data-cfasync="false" crossorigin="anonymous"
  src="https://cdn.jsdelivr.net/npm/@babel/standalone/babel.min.js"
  onerror="__fail('Babel failed to load', this.src)"></script>
<script data-cfasync="false">
  if (!window.React) __fail('React global missing (post-load)', 'react@18');
  if (!window.ReactDOM) __fail('ReactDOM global missing (post-load)', 'react-dom@18');
  if (!window.Babel) __fail('Babel global missing (post-load)', '@babel/standalone');
</script>

<script data-cfasync="false" type="text/babel">

    const { useState, useEffect, useMemo, useRef, useCallback } = React;

    // ---------- IndexedDB ----------
    const DB_NAME = 'modelMatchupDB';
    const DB_STORE = 'items';

    const canUseIndexedDB = () => {
      try{
        return typeof indexedDB !== 'undefined';
      }catch(err){
        return false;
      }
    };

    function openDB(){
      if(!canUseIndexedDB()){
        return Promise.reject(new Error('IndexedDB unavailable'));
      }
      return new Promise((resolve,reject)=>{
        const req = indexedDB.open(DB_NAME,1);
        req.onupgradeneeded = () => {
          const db = req.result;
          if(!db.objectStoreNames.contains(DB_STORE)){
            db.createObjectStore(DB_STORE,{keyPath:'id'});
          }
        };
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
      });
    }
    async function idbGetAll(){
      let db;
      try{
        db = await openDB();
      }catch(err){
        console.warn('IndexedDB unavailable, running without local storage.', err);
        return [];
      }
      return new Promise((res,rej)=>{
        const tx = db.transaction(DB_STORE,'readonly');
        const st = tx.objectStore(DB_STORE);
        const out = [];
        const cur = st.openCursor();
        cur.onsuccess = e => {
          const c = e.target.result;
          if(c){ out.push(c.value); c.continue(); }
          else res(out);
        };
        cur.onerror = () => rej(cur.error);
      });
    }
    function mergeLargeFields(existing, incoming){
      if (!existing) return incoming;
      if (!incoming) return existing;

      const merged = { ...existing, ...incoming };
      const preserveFields = ['dataUrl', 'thumbnail', 'thumbDataUrl', 'fullUrl'];

      for (const field of preserveFields) {
        if (incoming[field] == null && existing[field] != null) {
          merged[field] = existing[field];
        }
      }

      return merged;
    }

    async function idbBulkPut(items){
      let db;
      try{
        db = await openDB();
      }catch(err){
        console.warn('IndexedDB unavailable, cannot persist items.', err);
        return;
      }
      return new Promise((res,rej)=>{
        const tx = db.transaction(DB_STORE,'readwrite');
        const st = tx.objectStore(DB_STORE);
        for(const it of items) st.put(it);
        tx.oncomplete = () => res();
        tx.onerror = () => rej(tx.error);
      });
    }
    async function idbBulkPutMerged(items){
      let db;
      try{
        db = await openDB();
      }catch(err){
        console.warn('IndexedDB unavailable, cannot persist items.', err);
        return;
      }
      return new Promise((res,rej)=>{
        const tx = db.transaction(DB_STORE,'readwrite');
        const st = tx.objectStore(DB_STORE);
        for (const item of items) {
          if (!item || !item.id) continue;
          const getReq = st.get(item.id);
          getReq.onsuccess = () => {
            const merged = mergeLargeFields(getReq.result, item);
            st.put(merged);
          };
          getReq.onerror = () => {
            st.put(item);
          };
        }
        tx.oncomplete = () => res();
        tx.onerror = () => rej(tx.error);
      });
    }

    async function idbPut(item){
      let db;
      try{
        db = await openDB();
      }catch(err){
        console.warn('IndexedDB unavailable, cannot persist item.', err);
        return;
      }
      return new Promise((res,rej)=>{
        const tx = db.transaction(DB_STORE,'readwrite');
        tx.objectStore(DB_STORE).put(item);
        tx.oncomplete = () => {
          res();
          if (window.saveItemToCloud) window.saveItemToCloud(item);
        };
        tx.onerror = () => rej(tx.error);
      });
    }

    async function idbPutMerged(item){
      let db;
      try{
        db = await openDB();
      }catch(err){
        console.warn('IndexedDB unavailable, cannot persist item.', err);
        return;
      }
      if (!item || !item.id) return;
      return new Promise((res,rej)=>{
        const tx = db.transaction(DB_STORE,'readwrite');
        const st = tx.objectStore(DB_STORE);
        const getReq = st.get(item.id);
        getReq.onsuccess = () => {
          const merged = mergeLargeFields(getReq.result, item);
          st.put(merged);
        };
        getReq.onerror = () => {
          st.put(item);
        };
        tx.oncomplete = () => {
          res();
          if (window.saveItemToCloud) window.saveItemToCloud(item);
        };
        tx.onerror = () => rej(tx.error);
      });
    }
    async function idbDelete(id){
      let db;
      try{
        db = await openDB();
      }catch(err){
        console.warn('IndexedDB unavailable, cannot delete item.', err);
        return;
      }
      return new Promise((res,rej)=>{
        const tx = db.transaction(DB_STORE,'readwrite');
        tx.objectStore(DB_STORE).delete(id);
        tx.oncomplete = () => res();
        tx.onerror = () => rej(tx.error);
      });
    }
    async function idbClear(){
      let db;
      try{
        db = await openDB();
      }catch(err){
        console.warn('IndexedDB unavailable, cannot clear items.', err);
        return;
      }
      return new Promise((res,rej)=>{
        const tx = db.transaction(DB_STORE,'readwrite');
        tx.objectStore(DB_STORE).clear();
        tx.oncomplete = () => res();
        tx.onerror = () => rej(tx.error);
      });
    }
// --- PASTE THIS AFTER idbClear ---
    
    // Low-memory way to get a map of ID -> Fingerprint

    async function getSmartLookupMap(){
      let db;
      try{
        db = await openDB();
      }catch(err){
        console.warn('IndexedDB unavailable, cannot build lookup map.', err);
        return { byId: new Map(), byFingerprint: new Map() };
      }
      return new Promise((res,rej)=>{
        const tx = db.transaction(DB_STORE,'readonly');
        const st = tx.objectStore(DB_STORE);
        const map = new Map(); // Map<id, fingerprint>
        const fpMap = new Map(); // Map<fingerprint, id>
        
        const cur = st.openCursor();
        cur.onsuccess = e => {
          const c = e.target.result;
          if(c){
            const val = c.value;
            const id = val.id;
            let fp = null;
            // Create fingerprint from first 120 chars of dataUrl
            if(val.dataUrl && typeof val.dataUrl === 'string'){
               fp = val.dataUrl.slice(0,120);
            }
            
            map.set(id, fp);
            if(fp) fpMap.set(fp, id);
            
            c.continue();
          }
          else res({ byId: map, byFingerprint: fpMap });
        };
        cur.onerror = () => rej(cur.error);
      });
    }

// --- NEW HELPERS FOR MEMORY MANAGEMENT ---

// 1. Fetch a SINGLE full item (High Res) from DB (you already have this)
async function idbGet(id){
  let db;
  try{
    db = await openDB();
  }catch(err){
    console.warn('IndexedDB unavailable, cannot read item.', err);
    return null;
  }
  return new Promise((res,rej)=>{
    const tx = db.transaction(DB_STORE,'readonly');
    const st = tx.objectStore(DB_STORE);
    const req = st.get(id);
    req.onsuccess = () => res(req.result);
    req.onerror = () => rej(req.error);
  });
}

// Turn a full DB record into a lightweight UI item
function mapDbRecordToUiItem(v){
  if (!v) return null;

  // Prefer true thumbnail fields. We *don‚Äôt* fall back to dataUrl here,
  // because most of your big base64 blobs have been cleaned up.
  const thumb = v.thumbnail || v.thumbDataUrl || null;

  return {
    id: v.id,

    // core metadata
    title: v.title || '',
    imageNumber: Number.isFinite(Number(v.imageNumber)) ? Number(v.imageNumber) : null,
    generator: v.generator || '',
    collections: normalizeCollections(v.collections || v.collectionsRaw || ''),

    wins: Number(v.wins || 0),
    losses: Number(v.losses || 0),
    tourneyBonus: Number(v.tourneyBonus || 0),
    tourneyCount: Number(v.tourneyCount || 0),

    addedAt: v.addedAt || nowStamp(),
    hasBeenExported:
      v.hasBeenExported === undefined ? true : !!v.hasBeenExported,
    lastExportedAt: v.lastExportedAt || null,

    // cloud image reference (what the migration + cleanup left behind)
    fullUrl: v.fullUrl || null,

    // UI image fields ‚Äì SMALL ONLY
    thumbnail: thumb,

    // avoid loading full dataUrl into state (saves memory on mobile)
    dataUrl: null
  };
}


// Load Library WITHOUT massive DataURLs (memory-safe)
async function loadOptimizedLibrary(){
  let db;
  try{
    db = await openDB();
  }catch(err){
    console.warn('IndexedDB unavailable, skipping library load.', err);
    return [];
  }

  return new Promise((resolve) => {
    const items = [];
    const tx = db.transaction(DB_STORE, 'readonly');
    const store = tx.objectStore(DB_STORE);
    const cursorReq = store.openCursor();

    cursorReq.onsuccess = (e) => {
      const cursor = e.target.result;
      if (!cursor) {
        resolve(items);
        return;
      }

      const v = cursor.value || {};
      const uiItem = mapDbRecordToUiItem(v);
      if (uiItem) items.push(uiItem);

      cursor.continue();
    };

    cursorReq.onerror = () => {
      console.error('loadOptimizedLibrary cursor error', cursorReq.error);
      resolve([]);
    };
  });
}


// 3. Batched Thumbnail Generator (memory-friendly, extra defensive)
async function generateMissingThumbnails_Safe(updateStatusCallback){
  let db;
  try{
    db = await openDB();
  }catch(err){
    console.warn('IndexedDB unavailable, skipping thumbnail generation.', err);
    return 0;
  }

  // 1) Grab all keys
  let keys = [];
  try {
    keys = await new Promise((resolve, reject) => {
      const tx = db.transaction(DB_STORE, 'readonly');
      const store = tx.objectStore(DB_STORE);
      const req  = store.getAllKeys();
      req.onsuccess = () => resolve(req.result || []);
      req.onerror   = () => reject(req.error);
    });
  } catch (err) {
    console.error('getAllKeys failed while generating thumbnails', err);
    return 0;
  }

  if (!Array.isArray(keys)) {
    try {
      keys = Array.from(keys || []);
    } catch (e) {
      console.error('Keys are not iterable, aborting thumbnail generation.', keys);
      return 0;
    }
  }

  console.log('Starting thumbnail batch. Total keys:', keys.length);

  // üîπ MUCH smaller batch size so we don‚Äôt blow up memory
  const MAX_PER_RUN = 5;
  let processed = 0;
  let generated = 0;

  for (let i = 0; i < keys.length && processed < MAX_PER_RUN; i++) {
    const id = keys[i];
    processed++;

    let item;
    try {
      item = await idbGet(id);    // own read tx
    } catch (e) {
      console.error('Failed to read item while generating thumbnail', id, e);
      continue;
    }

// skip if no image source or already has new-style thumb
const src =
  item.dataUrl ||
  item.fullUrl ||
  item.thumbnail ||
  item.thumbDataUrl;

if (!item || !src || item.thumbDataUrl) {
  continue;
}

let thumb;
try {
  thumb = await dataUrlToThumbDataUrl(src, 480, 0.8);
} catch (e) {
  console.error('Failed to create thumbnail for', id, e);
  continue;
}


    // ‚úÖ Write to BOTH fields so old + new paths can use it
    item.thumbnail    = thumb;
    item.thumbDataUrl = thumb;

    try {
      await idbPut(item);    // own write tx
      generated++;

      if (updateStatusCallback && generated % 5 === 0) {
        updateStatusCallback(`Generated ${generated} thumbnails this run...`);
      }
    } catch (e) {
      console.error('Failed to save thumbnail for', id, e);
      continue;
    }

    // üîπ Yield EVERY item so GC can breathe
    await new Promise(r => setTimeout(r, 0));
  }

  console.log(`Thumbnail batch finished. Generated: ${generated}, processed: ${processed}`);
  return generated;
}


// 4. Public function wired to the ‚ÄúGenerate thumbnails‚Äù button
async function generateMissingThumbnails(){
  const ok = confirm(
    "This process will scan all images and create small thumbnails to speed up the app.\n\n" +
    "It may take a few minutes. Keep this tab open."
  );
  if (!ok) return;

  try {
    const count = await generateMissingThumbnails_Safe((status) => {
      console.log(status);
    });

    // Reload using the optimized loader so we drop full dataUrls from state
    let fresh = [];
    try {
      fresh = await loadOptimizedLibrary();
    } catch (e) {
      console.error('loadOptimizedLibrary failed after thumbnail generation, falling back to idbGetAll', e);
      fresh = await idbGetAll();
    }

    const norm = fresh.map(it => ({
      // keep whatever is in the DB record
      ...it,

      // normalize / enforce fields
      title: it.title || '',
      generator: it.generator || '',
      collections: normalizeCollections(it.collections || it.collectionsRaw || ''),
      wins: Number(it.wins || 0),
      losses: Number(it.losses || 0),
      tourneyBonus: Number(it.tourneyBonus || 0),
      tourneyCount: Number(it.tourneyCount || 0),
      addedAt: it.addedAt || nowStamp(),
      hasBeenExported: !!it.hasBeenExported,
      lastExportedAt: it.lastExportedAt || null,
      // unify thumbnail field again
      thumbnail: it.thumbnail || it.thumbDataUrl || null,
      dataUrl: it.dataUrl || null
    }));

    setItems(norm);
    alert(`Generated thumbnails for ${count} images.`);
  } catch (e) {
    console.error('generateMissingThumbnails failed', e);
    alert('Failed to generate thumbnails: ' + (e && e.message ? e.message : String(e)));
  }
}




    // --- END PASTE ---
    // ---------- Utils ----------
    const pct = (w,l)=> {
      const t = (w||0)+(l||0);
      return t===0 ? 0 : (w||0)/t;
    };
    const matchupsCount = it => (it.wins||0)+(it.losses||0);

    const compareBySort = (a, b, sort) => {
      const dir = sort.dir === 'asc' ? 1 : -1;
      if (sort.field === 'addedAt') {
        const ta = new Date(a.addedAt || 0).getTime();
        const tb = new Date(b.addedAt || 0).getTime();
        return (tb - ta) * dir;
      } else if (sort.field === 'title') {
        return (a.title || '').localeCompare(b.title || '') * dir;
      } else if (sort.field === 'points') {
        const pa = computePoints(a.wins, a.losses, a.tourneyBonus || 0);
        const pb = computePoints(b.wins, b.losses, b.tourneyBonus || 0);
        if (pb !== pa) return (pb - pa) * dir;
        return (matchupsCount(b) - matchupsCount(a)) * dir;
      } else if (sort.field === 'matchups') {
        return (matchupsCount(b) - matchupsCount(a)) * dir;
      }
      return 0;
    };

    // UPDATED: include tourneyBonus
    const computePoints = (w,l,tourneyBonus=0)=>{
      const W = w||0, L = l||0;
      const B = tourneyBonus || 0;
      let pts = W*2 - L + B;
      if(W>0 && L===0) pts += 5;
      return pts;
    };
    const tourneyWinsFromBonus = (tourneyBonus=0)=>{
      return Math.max(0, Math.floor((tourneyBonus || 0) / 5));
    };

const normalizeCollectionName = (value)=>String(value || '').trim().toLowerCase();

const normalizeCollections = (value)=>{
  if(!value) return [];
  // Allow trailing commas/empties so typing commas in the input feels natural;
  // empty names are ignored elsewhere in the app.
  const parts = Array.isArray(value) ? value : String(value).split(',');
  return Array.from(new Set(
    parts
      .map(normalizeCollectionName)
      .filter(Boolean)
  ));
};

const normalizeCollectionMembers = (value)=>{
  if(Array.isArray(value)){
    return Array.from(new Set(
      value
        .map(normalizeCollectionName)
        .filter(Boolean)
        .sort((a,b)=>a.localeCompare(b))
    ));
  }
  if(typeof value === 'string'){
    return normalizeCollections(value);
  }
  return [];
};

const normalizeCollectionGroupsInput = (groups)=>{
  if(!Array.isArray(groups)) return [];
  return groups.map((g,idx)=>{
    const members = normalizeCollectionMembers(g && g.members);
    const id = (g && g.id) || createId();
    const nameRaw = g && g.name ? String(g.name).trim() : '';
    const name = nameRaw || 'Group';
    const open = g && g.open === false ? false : true;
    return {id, name, members, open};
  });
};

const mergeCollectionGroups = (groups)=>{
  const normalized = normalizeCollectionGroupsInput(groups);
  const map = new Map();
  const dedupeKey = (g)=>g.id || g.name.toLowerCase();
  for(const g of normalized){
    const key = dedupeKey(g);
    if(map.has(key)){
      const existing = map.get(key);
      const mergedMembers = normalizeCollectionMembers([...(existing.members||[]), ...(g.members||[])]);
      map.set(key, {...existing, ...g, members: mergedMembers});
    }else{
      map.set(key, g);
    }
  }
  return Array.from(map.values());
};

const normalizeCollectionGroupsForExport = (groups, allowedCollectionNames)=>{
  const allowed = new Set(allowedCollectionNames || []);
  return normalizeCollectionGroupsInput(groups)
    .map(g=>({
      ...g,
      members: (g.members || []).filter(name=>allowed.size===0 || allowed.has(name))
    }));
};

// Generator group helpers (mirrors the collection helpers above)
const normalizeGeneratorMembers = normalizeCollectionMembers;
const normalizeGeneratorGroupsInput = normalizeCollectionGroupsInput;
const mergeGeneratorGroups = mergeCollectionGroups;
const normalizeGeneratorGroupsForExport = normalizeCollectionGroupsForExport;

const normalizeGeneratorCatalog = (value)=>{
  return normalizeCollectionMembers(value)
    .filter(name => name && name.toLowerCase() !== 'unspecified');
};

const loadGeneratorCatalog = ()=>{
  if(typeof localStorage==='undefined') return [];
  try{
    const raw = localStorage.getItem('generatorCatalog');
    if(raw){
      const parsed = JSON.parse(raw);
      if(parsed && Array.isArray(parsed.names)){
        return normalizeGeneratorCatalog(parsed.names);
      }
    }
  }catch(err){
    console.warn('Failed to load generator catalog', err);
  }
  return [];
};

const persistGeneratorCatalog = (names)=>{
  if(typeof localStorage==='undefined') return;
  try{
    localStorage.setItem('generatorCatalog', JSON.stringify({names: normalizeGeneratorCatalog(names)}));
  }catch(err){
    console.warn('Failed to persist generator catalog', err);
  }
};

const mergeGeneratorCatalog = (current, incoming)=>{
  return normalizeGeneratorCatalog([...(current || []), ...(incoming || [])]);
};

    const detectViewportMode = () => {
      if (typeof window === 'undefined') return 'desktop';
      const isPortrait = window.matchMedia('(orientation: portrait)').matches;
      const isLandscape = window.matchMedia('(orientation: landscape)').matches;
      const isMobileWidth = window.innerWidth <= 900;
      if (isMobileWidth) {
        if (isPortrait) return 'mobile-portrait';
        if (isLandscape) return 'mobile-landscape';
        return 'mobile-portrait';
      }
      return 'desktop';
    };

    const columnOptionsForMode = (mode) => {
      if (mode === 'mobile-portrait') return [1,2,3];
      if (mode === 'mobile-landscape') return [2,3,4,5];
      return [3,4,5,6];
    };

    const defaultColumnsForMode = (mode) => {
      if (mode === 'mobile-portrait') return 2;
      if (mode === 'mobile-landscape') return 3;
      return 4;
    };

const collectionsToString = arr => (arr && arr.length ? arr.join(', ') : '');
    const nowStamp = ()=>{
      const d = new Date();
      const pad = n => String(n).padStart(2,'0');
      return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
    };

const TITLE_MAX_LENGTH = 25;
const DISPLAY_TITLE_MAX_LENGTH = 20;

const trimTitle = (value) => {
  if (typeof value !== 'string') return '';
  return value.length > TITLE_MAX_LENGTH ? value.slice(0, TITLE_MAX_LENGTH) : value;
};

const formatDisplayTitle = (value) => {
  const text = typeof value === 'string' ? value : '';
  if (!text) return '';
  return text.length > DISPLAY_TITLE_MAX_LENGTH
    ? `${text.slice(0, DISPLAY_TITLE_MAX_LENGTH)}‚Ä¶`
    : text;
};

const createId = () => {
  if (typeof crypto !== 'undefined' && crypto.randomUUID) {
    return crypto.randomUUID();
  }
  return `${Date.now()}-${Math.random().toString(16).slice(2)}`;
};

const getAddedAtTime = (value) => {
  const parsed = new Date(value || 0).getTime();
  return Number.isFinite(parsed) ? parsed : 0;
};

const assignImageNumbersByAddedAt = (itemsList) => {
  const sorted = [...itemsList].sort((a, b) => {
    const ta = getAddedAtTime(a.addedAt);
    const tb = getAddedAtTime(b.addedAt);
    if (ta !== tb) return ta - tb;
    return String(a.id || '').localeCompare(String(b.id || ''));
  });
  const numberMap = new Map();
  let expected = 1;
  for (const it of sorted) {
    numberMap.set(it.id, expected);
    expected += 1;
  }
  let changed = false;
  const updated = itemsList.map(it => {
    const nextNumber = numberMap.get(it.id);
    if (it.imageNumber === nextNumber) return it;
    changed = true;
    return {
      ...it,
      imageNumber: nextNumber
    };
  });
  return { updated, changed };
};

const getNextImageNumber = (itemsList) => {
  let max = 0;
  for (const it of itemsList) {
    if (Number.isFinite(it.imageNumber) && it.imageNumber > max) {
      max = it.imageNumber;
    }
  }
  return max + 1;
};

function formatAddedAt(ts){
  if(!ts) return '';

  // Try to parse whatever format was saved
  const d = new Date(ts);
  if(isNaN(d)) return ts; // fallback if unparseable

  const options = { month: 'short', day: 'numeric', year: 'numeric' };
  const dateStr = d.toLocaleDateString('en-US', options);

  const hh = String(d.getHours()).padStart(2,'0');
  const mm = String(d.getMinutes()).padStart(2,'0');
  const ss = String(d.getSeconds()).padStart(2,'0');
  const timeStr = `${hh}:${mm}:${ss}`;

  return `${dateStr}\n${timeStr}`;
}

function toDateTimeLocalValue(ts){
  if(!ts) return '';
  const d = new Date(ts);
  if(isNaN(d)) return '';
  const pad = n => String(n).padStart(2,'0');
  return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}T${pad(d.getHours())}:${pad(d.getMinutes())}`;
}

function fromDateTimeLocalValue(value){
  if(!value) return '';
  const d = new Date(value);
  if(isNaN(d)) return value;
  const pad = n => String(n).padStart(2,'0');
  return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
}

    // image format detection once
    const CANVAS_FORMAT = (()=>{
      try{
        const c = document.createElement('canvas');
        if(c.toDataURL){
          const av = c.toDataURL('image/avif');
          if(av && av.startsWith('data:image/avif')) return 'image/avif';
          const wp = c.toDataURL('image/webp');
          if(wp && wp.startsWith('data:image/webp')) return 'image/webp';
        }
      }catch(e){}
      return 'image/jpeg';
    })();

    function fitWithin(sw,sh,maxSide){
      const s = Math.min(maxSide/sw, maxSide/sh, 1);
      return { w:Math.round(sw*s), h:Math.round(sh*s) };
    }

function sleep(ms){
  return new Promise(resolve => setTimeout(resolve, ms));
}

    // *** UPDATED: default maxSide 1500 + quality 0.95 ***
    async function fileToCompressedDataUrl(file,maxSide=1500){
      const dataUrl = await new Promise((resolve,reject)=>{
        const img = new Image();
        img.onload = ()=> resolve(img);
        img.onerror = reject;
        img.src = URL.createObjectURL(file);
      }).then(img=>{
        const {w,h} = fitWithin(img.naturalWidth,img.naturalHeight,maxSide);
        const c = document.createElement('canvas');
        c.width = w;
        c.height = h;
        const ctx = c.getContext('2d');
        ctx.drawImage(img,0,0,w,h);
        return c.toDataURL(CANVAS_FORMAT,0.95);
      });
      return dataUrl;
    }

async function dataUrlToThumbDataUrl(src, maxSide = 320, quality = 0.80){
  const dataUrl = await new Promise((resolve, reject)=>{
    const img = new Image();
    img.onload = ()=> resolve(img);
    img.onerror = reject;
    img.src = src;
  }).then(img=>{
    const {w,h} = fitWithin(img.naturalWidth,img.naturalHeight,maxSide);
    const c = document.createElement('canvas');
    c.width = w;
    c.height = h;
    const ctx = c.getContext('2d');
    ctx.drawImage(img,0,0,w,h);
    return c.toDataURL(CANVAS_FORMAT, quality);
  });
  return dataUrl;
}


    function encodeCanvas(canvas){
      try{
        return canvas.toDataURL(CANVAS_FORMAT,0.95);
      }catch(e){
        return canvas.toDataURL('image/jpeg',0.95);
      }
    }

    function encodeCanvasLossless(canvas){
      return canvas.toDataURL('image/png');
    }

    function generatorNameForMatchup(item){
      return (item?.generator || '').trim() || 'Unspecified';
    }

    // pickTwo with weight by fewer matchups
    function pickTwoFromPool(pool){
      if(!pool || pool.length<2) return [null,null];
      const totals = pool.map(matchupsCount);
      const minT = Math.min(...totals);
      const weights = totals.map(t=>1/((t-minT)+1));
      function draw(excludeId){
        let totalW = 0;
        for(let i=0;i<pool.length;i++){
          if(pool[i].id===excludeId) continue;
          totalW += weights[i];
        }
        let r = Math.random()*totalW;
        for(let i=0;i<pool.length;i++){
          if(pool[i].id===excludeId) continue;
          r -= weights[i];
          if(r<=0) return pool[i].id;
        }
        for(let i=0;i<pool.length;i++){
          if(pool[i].id!==excludeId) return pool[i].id;
        }
        return pool[0].id;
      }
      const id1 = draw();
      const id2 = draw(id1);
      return [id1,id2];
    }

    function pickTwoFromPoolDifferentGenerators(pool){
      if(!pool || pool.length<2) return [null,null];
      const totals = pool.map(matchupsCount);
      const minT = Math.min(...totals);
      const weights = totals.map(t=>1/((t-minT)+1));
      const generatorById = new Map(pool.map(item=>[item.id, generatorNameForMatchup(item)]));
      function draw(excludeId, excludeGenerator){
        let totalW = 0;
        for(let i=0;i<pool.length;i++){
          if(pool[i].id===excludeId) continue;
          if(excludeGenerator && generatorById.get(pool[i].id)===excludeGenerator) continue;
          totalW += weights[i];
        }
        if(totalW<=0) return null;
        let r = Math.random()*totalW;
        for(let i=0;i<pool.length;i++){
          if(pool[i].id===excludeId) continue;
          if(excludeGenerator && generatorById.get(pool[i].id)===excludeGenerator) continue;
          r -= weights[i];
          if(r<=0) return pool[i].id;
        }
        for(let i=0;i<pool.length;i++){
          if(pool[i].id===excludeId) continue;
          if(excludeGenerator && generatorById.get(pool[i].id)===excludeGenerator) continue;
          return pool[i].id;
        }
        return null;
      }
      const id1 = draw();
      if(!id1) return [null,null];
      const id2 = draw(id1, generatorById.get(id1));
      if(!id2) return [null,null];
      return [id1,id2];
    }

    // flat random (no weighting) selector
    function pickTwoFromPoolFlat(pool){
      if(!pool || pool.length<2) return [null,null];
      const len = pool.length;
      const i1 = Math.floor(Math.random()*len);
      let i2 = Math.floor(Math.random()*(len-1));
      if(i2>=i1) i2++;
      return [pool[i1].id, pool[i2].id];
    }

    function pickLockedMatch(pool, lockedId){
      if(!lockedId) return [null,null];
      if(!pool || pool.length<2) return [lockedId,null];
      const lockedExists = pool.some(it=>it.id===lockedId);
      if(!lockedExists) return [null,null];
      const opponents = pool.filter(it=>it.id!==lockedId);
      if(!opponents.length) return [lockedId,null];
      const idx = Math.floor(Math.random()*opponents.length);
      return [lockedId, opponents[idx].id];
    }

    // ---------- Cropper hook ----------
    function useCropper(){
      const [crop,setCrop] = useState(null); // {img, iw, ih, rect, targetId}
      const ref = useRef(null);
      const cropLoadRef = useRef(0);

      function dims(iw,ih){
        const maxW = Math.min(window.innerWidth*0.86,1200);
        const maxH = Math.min(window.innerHeight*0.70,900);
        const s = Math.min(maxW/iw,maxH/ih,1);
        return {cw:Math.round(iw*s),ch:Math.round(ih*s),scale:s,dpr:Math.max(1,Math.min(3,window.devicePixelRatio||1))};
      }
      function canvasPoint(e){
        const c = ref.current;
        const r = c.getBoundingClientRect();
        const p = e.touches?e.touches[0]:e;
        return {x:p.clientX-r.left,y:p.clientY-r.top};
      }
      function draw(current=crop){
        if(!current) return;
        const c = ref.current;
        const {cw,ch,scale,dpr} = dims(current.iw,current.ih);
        c.style.width = cw+'px';
        c.style.height = ch+'px';
        c.width = Math.round(cw*dpr);
        c.height = Math.round(ch*dpr);
        const ctx = c.getContext('2d');
        ctx.setTransform(dpr,0,0,dpr,0,0);
        ctx.clearRect(0,0,cw,ch);
        ctx.drawImage(current.img,0,0,cw,ch);
        const rx = current.rect.x*scale;
        const ry = current.rect.y*scale;
        const rw = current.rect.w*scale;
        const rh = current.rect.h*scale;
        ctx.save();
        ctx.fillStyle = 'rgba(0,0,0,0.45)';
        ctx.beginPath();
        ctx.rect(0,0,cw,ch);
        ctx.rect(rx,ry,rw,rh);
        ctx.fill('evenodd');
        ctx.restore();
        ctx.strokeStyle = '#1f9d73';
        ctx.lineWidth = 2;
        ctx.strokeRect(rx,ry,rw,rh);
        const s = 8;
        ctx.fillStyle = '#1f9d73';
        ctx.fillRect(rx-s,ry-s,s*2,s*2);
        ctx.fillRect(rx+rw-s,ry-s,s*2,s*2);
        ctx.fillRect(rx-s,ry+rh-s,s*2,s*2);
        ctx.fillRect(rx+rw-s,ry+rh-s,s*2,s*2);
      }
      useEffect(()=>{ if(crop) draw(crop); },[crop]);

      async function resolveCropSources(item){
        // Build a prioritized list of possible image sources, including IndexedDB.
        const candidates = [];
        const add = (src, priority) => {
          if(!isNonEmptySrc(src)) return;
          if(candidates.some(c=>c.src===src)) return;
          candidates.push({src,priority});
        };

        const addFrom = (obj) => {
          if(!obj) return;
          add(obj.fullUrl, 0);
          add(obj.dataUrl, 1);
          add(obj.thumbnail, 2);
          add(obj.thumbDataUrl, 3);
        };

        addFrom(item);

        if (item.id){
          try{
            const full = await idbGet(item.id);
            addFrom(full);
          }catch(e){
            console.error('Failed to hydrate image for cropping', e);
          }
        }

        // Always try to pull the freshest full-resolution image from Firebase
        if (item?.id && window.fetchFullImageUrl){
          try{
            const remoteFull = await window.fetchFullImageUrl(item.id);
            add(remoteFull, -1);
          }catch(err){
            console.warn('Full image unavailable during cropping', err);
          }
        }

        const sorted = candidates
          .sort((a,b)=>a.priority-b.priority)
          .map(c=>c.src);
        return dedupeSources(sorted);
      }

      async function startForItem(item){
        const sources = await resolveCropSources(item);
        if(!sources.length){
          alert('Unable to load this image for cropping.');
          return;
        }
        const loadToken = ++cropLoadRef.current;

        const tryLoad = (idx) => {
          if(loadToken !== cropLoadRef.current) return;
          if(idx >= sources.length){
            alert('Unable to load this image for cropping.');
            return;
          }

          const img = new Image();
          const src = sources[idx];
          if(/^https?:\/\//i.test(src)){
            img.crossOrigin = 'anonymous';
          }
          img.onload = ()=>{
            if(loadToken !== cropLoadRef.current) return;
            const iw = img.naturalWidth;
            const ih = img.naturalHeight;
            const size = Math.min(iw,ih)*0.8;
            setCrop({
              img, iw, ih,
              rect:{x:(iw-size)/2,y:(ih-size)/2,w:size,h:size},
              targetId:item.id
            });
          };
          img.onerror = (e)=>{
            if(loadToken !== cropLoadRef.current) return;
            console.warn('Crop image failed to load, trying fallback', e);
            tryLoad(idx+1);
          };
          img.src = src;
        };

        tryLoad(0);
      }

      function onPointerDown(e){
        if(!crop) return;
        const startPt = canvasPoint(e);
        const {scale} = dims(crop.iw,crop.ih);
        const rx = crop.rect.x*scale;
        const ry = crop.rect.y*scale;
        const rw = crop.rect.w*scale;
        const rh = crop.rect.h*scale;
        const s = 10;
        let mode = 'move';
        if(Math.abs(startPt.x-rx)<s && Math.abs(startPt.y-ry)<s) mode='tl';
        else if(Math.abs(startPt.x-(rx+rw))<s && Math.abs(startPt.y-ry)<s) mode='tr';
        else if(Math.abs(startPt.x-rx)<s && Math.abs(startPt.y-(ry+rh))<s) mode='bl';
        else if(Math.abs(startPt.x-(rx+rw))<s && Math.abs(startPt.y-(ry+rh))<s) mode='br';

        const startRect = {...crop.rect};

        function onMove(ev){
          const p = canvasPoint(ev);
          const dx = (p.x-startPt.x)/scale;
          const dy = (p.y-startPt.y)/scale;
          let r = {...startRect};
          if(mode==='move'){
            r.x = Math.min(crop.iw-r.w, Math.max(0,startRect.x+dx));
            r.y = Math.min(crop.ih-r.h, Math.max(0,startRect.y+dy));
          }else if(mode==='tl'){
            r.x = Math.min(startRect.x+startRect.w-10, Math.max(0,startRect.x+dx));
            r.y = Math.min(startRect.y+startRect.h-10, Math.max(0,startRect.y+dy));
            r.w = startRect.w-(r.x-startRect.x);
            r.h = startRect.h-(r.y-startRect.y);
          }else if(mode==='tr'){
            r.y = Math.min(startRect.y+startRect.h-10, Math.max(0,startRect.y+dy));
            r.w = Math.min(crop.iw-startRect.x-10, Math.max(10,startRect.w+dx));
            r.h = startRect.h-(r.y-startRect.y);
          }else if(mode==='bl'){
            r.x = Math.min(startRect.x+startRect.w-10, Math.max(0,startRect.x+dx));
            r.w = startRect.w-(r.x-startRect.x);
            r.h = Math.min(crop.ih-startRect.y-10, Math.max(10,startRect.h+dy));
          }else if(mode==='br'){
            r.w = Math.min(crop.iw-startRect.x-10, Math.max(10,startRect.w+dx));
            r.h = Math.min(crop.ih-startRect.y-10, Math.max(10,startRect.h+dy));
          }
          setCrop(c=>({...c,rect:r}));
          draw({...crop,rect:r});
        }
        function end(){
          window.removeEventListener('mousemove',onMove);
          window.removeEventListener('mouseup',end);
          window.removeEventListener('touchmove',onMove);
          window.removeEventListener('touchend',end);
        }
        window.addEventListener('mousemove',onMove);
        window.addEventListener('mouseup',end);
        window.addEventListener('touchmove',onMove,{passive:false});
        window.addEventListener('touchend',end);
      }

      function apply(){
        if(!crop) return null;
        const r = crop.rect;
        const max = 1500;
        const c = document.createElement('canvas');
        const scale = Math.min(max/r.w,max/r.h,1);
        c.width = Math.round(r.w*scale);
        c.height = Math.round(r.h*scale);
        const ctx = c.getContext('2d');
        ctx.drawImage(
          crop.img,
          r.x,r.y,r.w,r.h,
          0,0,c.width,c.height
        );
        return { dataUrl: encodeCanvasLossless(c), targetId: crop.targetId };
      }

      return { ref, crop, setCrop, startForItem, onPointerDown, apply };
    }

// ... useCropper ends above here ...

const MatchCard = ({ item, onClick, result }) => {
  const [highResSrc, setHighResSrc] = useState(
    item.fullUrl || item.dataUrl || item.thumbnail
  );

  useEffect(() => {
    // If we already have a cloud URL, just use that and stop.
    if (item.fullUrl) {
      setHighResSrc(item.fullUrl);
      return;
    }

    // Fall back to local dataUrl / thumbnail
    if (item.dataUrl) {
      setHighResSrc(item.dataUrl);
      return;
    }

    // Old "lightweight" items: try to hydrate from IndexedDB if needed
    if (item.id) {
      idbGet(item.id).then(full => {
        if (full) {
          setHighResSrc(full.fullUrl || full.dataUrl || full.thumbnail || highResSrc);
        }
      });
    }
  }, [item.id, item.fullUrl, item.dataUrl]);

  return (
    <div
      className={`match-card ${result || ''}`}
      onClick={() => onClick(item.id)}
    >
      <div className="img-container">
        <SafeImage item={item} src={highResSrc} fallbackSrcs={getDisplaySources(item)} alt={item.title} className="match-img" />
        {result && (
          <div className={`overlay ${result}`}>
            {result === 'win' ? 'WINNER' : 'ELIMINATED'}
          </div>
        )}
      </div>
      <div className="match-info">
        <div className="match-title">{formatDisplayTitle(item.title) || 'Untitled'}</div>
        <div className="match-stats">
          Wins: {item.wins} | Losses: {item.losses}
        </div>
      </div>
    </div>
  );
};

const ImageModal = ({ item, onClose, onSave, onDelete, generatorOptions = [] }) => {
      const [editedTitle, setEditedTitle] = useState(item.title);
      const [editedCollections, setEditedCollections] = useState(item.collections.join(', '));
      const [editedGenerator, setEditedGenerator] = useState(item.generator || '');
      const [editedWins, setEditedWins] = useState(String(item.wins ?? 0));
      const [editedLosses, setEditedLosses] = useState(String(item.losses ?? 0));
      const [editedTourneyCount, setEditedTourneyCount] = useState(String(item.tourneyCount ?? 0));
      const [editedTourneyWins, setEditedTourneyWins] = useState(String(tourneyWinsFromBonus(item.tourneyBonus || 0)));
      const [editedAddedAt, setEditedAddedAt] = useState(toDateTimeLocalValue(item.addedAt));
      
      // Lazy Load High Res (This is the memory-safe part)
const [displaySrc, setDisplaySrc] = useState(
  item.fullUrl || item.dataUrl || item.thumbnail
);

useEffect(() => {
  // Prefer cloud URL if we have it
  if (item.fullUrl) {
    setDisplaySrc(item.fullUrl);
    return;
  }

  if (item.dataUrl) {
    setDisplaySrc(item.dataUrl);
    return;
  }

  if (item.id) {
    idbGet(item.id).then(full => {
      if (full) {
        setDisplaySrc(full.fullUrl || full.dataUrl || full.thumbnail || displaySrc);
      }
    });
  }
}, [item.id, item.fullUrl, item.dataUrl]);

      
      const handleSave = () => {
        onSave(item.id, {
          title: editedTitle,
          collections: normalizeCollections(editedCollections),
          generator: editedGenerator,
          wins: Number(editedWins || 0),
          losses: Number(editedLosses || 0),
          tourneyCount: Number(editedTourneyCount || 0),
          tourneyBonus: Number(editedTourneyWins || 0) * 5,
          addedAt: editedAddedAt ? fromDateTimeLocalValue(editedAddedAt) : item.addedAt
        });
      };

      return (
        <div className="modal" onClick={onClose}>
          <div className="modalInner" onClick={e => e.stopPropagation()}>
            <div className="modal-img-container">
              {/* NOTE: If SafeImage is undefined, change this to <img src={displaySrc} className="modal-img" /> */}
              <SafeImage item={item} src={displaySrc} fallbackSrcs={getDisplaySources(item)} className="modal-img" />
            </div>
            <div style={{display:'flex', gap:10, flexDirection:'column'}}>
               <input 
                 type="text" 
                 value={editedTitle} 
                 onChange={e=>setEditedTitle(e.target.value)} 
                 className="input" 
                 placeholder="Title"
               />
               <input 
                 type="text" 
                 value={editedCollections} 
                 onChange={e=>setEditedCollections(e.target.value)} 
                 className="input" 
                 placeholder="Collections (comma sep)"
               />
               <select
                 className="select"
                 value={editedGenerator}
                 onChange={e=>setEditedGenerator(e.target.value)}
               >
                 {generatorOptions.map(opt=>(
                   <option key={opt.label} value={opt.value}>{opt.label}</option>
                 ))}
               </select>
               <input
                 type="number"
                 min="0"
                 value={editedWins}
                 onChange={e=>setEditedWins(e.target.value)}
                 className="input"
                 placeholder="Wins"
               />
               <input
                 type="number"
                 min="0"
                 value={editedLosses}
                 onChange={e=>setEditedLosses(e.target.value)}
                 className="input"
                 placeholder="Losses"
               />
               <input
                 type="number"
                 min="0"
                 value={editedTourneyCount}
                 onChange={e=>setEditedTourneyCount(e.target.value)}
                 className="input"
                 placeholder="Tournaments"
               />
               <input
                 type="number"
                 min="0"
                 value={editedTourneyWins}
                 onChange={e=>setEditedTourneyWins(e.target.value)}
                 className="input"
                 placeholder="Tournament wins"
               />
               <input
                 type="datetime-local"
                 value={editedAddedAt}
                 onChange={e=>setEditedAddedAt(e.target.value)}
                 className="input"
               />
            </div>
            <div className="modalFooter">
              <button className="btn danger" onClick={()=> onDelete(item.id)}>Delete</button>
              <div style={{flex:1}}></div>
              <button className="btn ghost" onClick={onClose}>Cancel</button>
              <button className="btn primary" onClick={handleSave}>Save</button>
            </div>
          </div>
        </div>
      );
    };

// Image source helpers
function isNonEmptySrc(src){
  return typeof src === 'string' && src.trim().length > 0;
}
function dedupeSources(list){
  const seen = new Set();
  const clean = [];
  for(const src of list){
    if(!isNonEmptySrc(src)) continue;
    if(seen.has(src)) continue;
    seen.add(src);
    clean.push(src);
  }
  return clean;
}
function getDisplaySources(item){
  if(!item) return [];
  return dedupeSources([
    item.thumbnail,
    item.thumbDataUrl,
    item.fullUrl,
    item.dataUrl
  ]);
}
// Matchups should prefer the full-size image whenever possible.
function getMatchupSources(item){
  if(!item) return [];
  return dedupeSources([
    item.fullUrl,
    item.dataUrl
  ]);
}
// Pick the best image source for matchups / small thumbs
function getDisplaySrc(item){
  const sources = getDisplaySources(item);
  return sources[0] || "";
}

function isHttpUrl(str){
  return typeof str === 'string' && /^https?:\/\//i.test(str);
}

// Very small preloader helper
function preloadImage(src){
  if (!src) return;
  const img = new Image();
  img.src = src; // browser will cache it
}

// Image component with automatic fallbacks + hydration
const SafeImage = ({
  src,
  fallbackSrcs = [],
  alt = '',
  className = '',
  style = {},
  item = null,
  onClick,
  onResolved,
  preferRemote = false,
  eagerHydrate = false
}) => {
  const queueRef = useRef([]);
  const hydratedRef = useRef(false);
  const [currentSrc, setCurrentSrc] = useState('');

  const rebuildQueue = useCallback((primary, fallbacks, targetItem) => {
    const ordered = dedupeSources([primary, ...(fallbacks || []), ...getDisplaySources(targetItem)]);
    queueRef.current = ordered;
    setCurrentSrc(ordered[0] || '');
    hydratedRef.current = false;
  }, []);

  useEffect(()=>{
    rebuildQueue(src, fallbackSrcs, item);
  },[src, fallbackSrcs, item?.id, item?.thumbnail, item?.thumbDataUrl, item?.fullUrl, item?.dataUrl, rebuildQueue]);

  useEffect(()=>{
    if(currentSrc || !item?.id) return;
    tryHydrate();
  },[currentSrc, item?.id, tryHydrate]);

  useEffect(()=>{
    if(!eagerHydrate || !item?.id) return;
    tryHydrate();
  },[eagerHydrate, item?.id, tryHydrate]);

  const tryHydrate = useCallback(async ()=>{
    if(!item || !item.id || hydratedRef.current) return null;
    hydratedRef.current = true;
    try{
      const full = await idbGet(item.id);
      const remote = window.fetchFullImageUrl ? await window.fetchFullImageUrl(item.id) : null;
      const merged = preferRemote
        ? dedupeSources([
            remote,
            ...queueRef.current,
            ...getDisplaySources(full)
          ])
        : dedupeSources([
            ...queueRef.current,
            ...getDisplaySources(full),
            remote
          ]);
      queueRef.current = merged;
      if(remote && onResolved){
        onResolved(remote);
      }
      const next = merged.find(url => url && url !== currentSrc);
      if(next){
        setCurrentSrc(next);
        return next;
      }
    }catch(err){
      console.warn('SafeImage hydration failed', err);
    }
    return null;
  },[item, currentSrc, onResolved, preferRemote]);

  const handleError = useCallback(async ()=>{
    const next = queueRef.current.find(url => url && url !== currentSrc);
    if(next){
      setCurrentSrc(next);
      return;
    }
    const hydrated = await tryHydrate();
    if(hydrated) return;
    setCurrentSrc('');
  },[currentSrc, tryHydrate]);

  return (
    <img
      src={currentSrc || undefined}
      alt={alt}
      className={className}
      style={{...style, visibility: currentSrc ? 'visible' : 'hidden'}}
      onError={handleError}
      onClick={onClick}
    />
  );
};


    // ... function App starts below here ...

    // ---------- Main App ----------
    function App(){
      const allowedTabs = ['Library','Matchups','Stats','Collections'];
      const initialTab = (()=>{
        try{
          const params = new URLSearchParams(window.location.search);
          const requested = params.get('tab');
          if(requested && allowedTabs.includes(requested)){
            return requested;
          }
        }catch(e){}
        return 'Library';
      })();

      const [tab,setTab] = useState(initialTab); // Library | Matchups | Stats | Collections
      const [items,setItems] = useState([]);
      const [matchIds,setMatchIds] = useState([null,null]);
      const [lastMatch,setLastMatch] = useState(null); // {winnerId, loserId, leftId, rightId}
      const [previewId,setPreviewId] = useState(null);
      const [previewSrc, setPreviewSrc] = useState(null);
      const [collectionTabView, setCollectionTabView] = useState('collections'); // collections | generators
      const [activeCollection,setActiveCollection] = useState(null); // name string
      const [activeCollectionType,setActiveCollectionType] = useState('collection'); // collection | generator
      const [collectionViewMode,setCollectionViewMode] = useState('gallery'); // gallery | cards
      const [libraryViewMode,setLibraryViewMode] = useState('cards'); // cards | gallery
      const [librarySort, setLibrarySort] = useState({field:'points', dir:'asc'});
      const [libraryFilter, setLibraryFilter] = useState('all'); // all | unassigned
      const [librarySearch, setLibrarySearch] = useState('');
      const [libraryCollectionFilter,setLibraryCollectionFilter] = useState({include:[],exclude:[],includeGroups:[],excludeGroups:[],mode:'all'});
      const [libraryGeneratorFilter,setLibraryGeneratorFilter] = useState({include:[],exclude:[],includeGroups:[],excludeGroups:[],mode:'all'});
      const [collectionStatsFilter,setCollectionStatsFilter] = useState({include:[],exclude:[],includeGroups:[],excludeGroups:[]});
      const [statsCollectionFilter,setStatsCollectionFilter] = useState({include:[],exclude:[],includeGroups:[],excludeGroups:[],mode:'all'});
      const [libraryCollectionEdits, setLibraryCollectionEdits] = useState({});
      const [collectionGroups, setCollectionGroups] = useState(()=>{
        if(typeof localStorage==='undefined') return [];
        try{
          const raw = localStorage.getItem('collectionGroups');
          if(raw){
            const parsed = JSON.parse(raw);
            if(parsed && Array.isArray(parsed.groups)){
              return normalizeCollectionGroupsInput(parsed.groups);
            }
          }
        }catch(err){
          console.warn('Failed to load collection groups', err);
        }
        return [];
      });
      const [generatorGroups, setGeneratorGroups] = useState(()=>{
        if(typeof localStorage==='undefined') return [];
        try{
          const raw = localStorage.getItem('generatorGroups');
          if(raw){
            const parsed = JSON.parse(raw);
            if(parsed && Array.isArray(parsed.groups)){
              return normalizeGeneratorGroupsInput(parsed.groups);
            }
          }
        }catch(err){
          console.warn('Failed to load generator groups', err);
        }
        return [];
      });
      const [customGenerators, setCustomGenerators] = useState(()=>loadGeneratorCatalog());
      const [libraryHydrated, setLibraryHydrated] = useState(false);
      const [statsSort,setStatsSort] = useState({field:'points',dir:'asc'});
      const [statsView,setStatsView] = useState('images');
      const [genStatsSort,setGenStatsSort] = useState({field:'pct',dir:'desc'});
      const [collStatsSort,setCollStatsSort] = useState({field:'pct',dir:'desc'});
      const [collectionSort, setCollectionSort] = useState({field:'points', dir:'asc'});
      const [matchMode,setMatchMode] = useState({type:'all', collection:null, generator:null, lockedId:null}); // all | bottom | collection | generator | generated | locked
      const [selectedIds,setSelectedIds] = useState([]); // for gallery batch + export
      const [batchOpen,setBatchOpen] = useState(false);
      const [batchCollectionsText,setBatchCollectionsText] = useState('');
      const [batchRemoveCollectionsText,setBatchRemoveCollectionsText] = useState('');
      const [batchReplaceFrom,setBatchReplaceFrom] = useState('');
      const [batchReplaceTo,setBatchReplaceTo] = useState('');
      const [batchGenerator,setBatchGenerator] = useState('__keep__');
      const [previewCollectionsText,setPreviewCollectionsText] = useState('');
      const [previewWins,setPreviewWins] = useState('');
      const [previewLosses,setPreviewLosses] = useState('');
      const [previewTourneyCount,setPreviewTourneyCount] = useState('');
      const [previewTourneyWins,setPreviewTourneyWins] = useState('');
      const [previewAddedAt,setPreviewAddedAt] = useState('');
      const [libraryPage,setLibraryPage] = useState(1);
      const [libraryPageSize,setLibraryPageSize] = useState(50);
      const [collectionPage,setCollectionPage] = useState(1);
      const [collectionPageSize,setCollectionPageSize] = useState(50);
      const [statsPage,setStatsPage] = useState(1);
      const [rankNotice, setRankNotice] = useState(null);
      const [rankNoticeVisible, setRankNoticeVisible] = useState(false);
      const rankNoticeTimers = useRef({hide:null, clear:null});
      const rankNoticeStorageKey = 'rankNoticeFeed';
      const topPointsPrevRef = useRef(null);
      const [viewportMode, setViewportMode] = useState(detectViewportMode()); // desktop | mobile-landscape | mobile-portrait
      const [libraryGalleryColumns, setLibraryGalleryColumns] = useState(()=>defaultColumnsForMode(detectViewportMode()));
      const [collectionGalleryColumns, setCollectionGalleryColumns] = useState(()=>defaultColumnsForMode(detectViewportMode()));
// If we were navigated to index.html?openId=<uuid>, auto-open that image
const [pendingOpenId, setPendingOpenId] = useState(() => {
  try {
    const params = new URLSearchParams(window.location.search);
    return params.get('openId');
  } catch (e) {
    return null;
  }
});

// --- ORPHAN / CLEANUP TOOLS ---
      const [cleanupModalOpen, setCleanupModalOpen] = useState(false);
      const [orphans, setOrphans] = useState(null); // null = waiting for file, [] = clean, [items] = orphans found
      const cleanupFileRef = useRef(null);

      async function analyzeForOrphans(file){
        try {
          const text = await file.text();
          const json = JSON.parse(text);
          
          if(!json.items || !Array.isArray(json.items)){
            alert("Invalid file format.");
            return;
          }

          // 1. Create a Set of all IDs that exist on Desktop
          const authorizedIds = new Set(json.items.map(it => it.id));

          // 2. Find items on Mobile that are NOT in that Set
          // We scan the current 'items' state (which matches the Mobile DB)
          const foundOrphans = items.filter(localItem => !authorizedIds.has(localItem.id));

          setOrphans(foundOrphans);
        } catch (e) {
          console.error(e);
          alert("Failed to parse file.");
        }
      }

      async function deleteOrphans(){
        if(!orphans || !orphans.length) return;
        if(!confirm(`Permanently delete ${orphans.length} orphaned images? This cannot be undone.`)) return;

        // Delete from IDB
        for(const it of orphans){
          await idbDelete(it.id);
        }

        // Update React State
        const orphanIds = new Set(orphans.map(o => o.id));
        setItems(prev => prev.filter(it => !orphanIds.has(it.id)));
        
        // Reset
        setOrphans([]);
        alert("Cleanup complete!");
        setCleanupModalOpen(false);
      }
      const statsPageSize = 250;

const fileRef = useRef(null);
const importRef = useRef(null);      // for JSON / metadata imports
const imageImportRef = useRef(null); // for image uploads
const cropper = useCropper();
const hydratingFullUrls = useRef(new Set());
const navMenuRef = useRef(null);

function commitLibraryCollections(id){
  const rawValue = libraryCollectionEdits[id];
  if(rawValue === undefined) return;
  const arr = normalizeCollections(rawValue);
  patchItem(id,{collections:arr});
  setLibraryCollectionEdits(prev=>{
    const next = {...prev};
    delete next[id];
    return next;
  });
}

// load from IDB (thumbnail-first)
useEffect(()=>{
  (async()=>{
    let all;
    try {
      all = await loadOptimizedLibrary();   // ‚úÖ use this
    } catch (e) {
      console.error('loadOptimizedLibrary failed on startup, falling back to idbGetAll', e);
      all = await idbGetAll();              // only as a fallback
    }

    let collectionsUpdated = false;
    const norm = all.map(it => {
      const normalizedCollections = normalizeCollections(it.collections || it.collectionsRaw || '');
      const collectionsChanged = !Array.isArray(it.collections)
        || it.collections.length !== normalizedCollections.length
        || it.collections.some((c,idx)=>c !== normalizedCollections[idx]);
      if(collectionsChanged) collectionsUpdated = true;
      return {
        ...it,
        // (normalization fields, but DON'T re-add full dataUrl here)
        collections: normalizedCollections,
        wins: Number(it.wins || 0),
        losses: Number(it.losses || 0),
        tourneyBonus: Number(it.tourneyBonus || 0),
        tourneyCount: Number(it.tourneyCount || 0),
        addedAt: it.addedAt || nowStamp(),
        hasBeenExported: !!it.hasBeenExported,
        lastExportedAt: it.lastExportedAt || null,
        imageNumber: Number.isFinite(it.imageNumber) ? it.imageNumber : null
      };
    });
    const { updated, changed } = assignImageNumbersByAddedAt(norm);
      if (changed || collectionsUpdated) {
        await idbBulkPutMerged(updated);
      }
    setItems(updated);
    if (norm.length >= 2){
      const [a,b] = pickTwoFromPool(norm);
      setMatchIds([a,b]);
    }
  })()
  .catch(e => console.error('Failed to hydrate library on startup', e))
  .finally(()=>{ setLibraryHydrated(true); });
},[]);

// Auto-open an image when arriving from duplicates.html with ?openId=<id>
useEffect(() => {
  if (!pendingOpenId) return;
  if (!items || !items.length) return;

  const exists = items.some(it => it.id === pendingOpenId);
  if (exists) {
    setTab('Library');
    setPreviewId(pendingOpenId);
  }

  // Only run once
  setPendingOpenId(null);
}, [pendingOpenId, items]);

// keep viewport mode + column defaults in sync with window size/orientation
useEffect(() => {
  const handler = () => {
    setViewportMode(detectViewportMode());
  };
  handler();
  window.addEventListener('resize', handler);
  window.addEventListener('orientationchange', handler);
  return () => {
    window.removeEventListener('resize', handler);
    window.removeEventListener('orientationchange', handler);
  };
}, []);

useEffect(() => {
  const options = columnOptionsForMode(viewportMode);
  setLibraryGalleryColumns(prev => options.includes(prev) ? prev : defaultColumnsForMode(viewportMode));
  setCollectionGalleryColumns(prev => options.includes(prev) ? prev : defaultColumnsForMode(viewportMode));
}, [viewportMode]);


      // sync preview collections text whenever previewId or items change
      useEffect(()=>{
        if(!previewId){
          setPreviewCollectionsText('');
          setPreviewWins('');
          setPreviewLosses('');
          setPreviewTourneyCount('');
          setPreviewTourneyWins('');
          setPreviewAddedAt('');
          return;
        }
        const it = items.find(x=>x.id===previewId);
        setPreviewCollectionsText(it ? collectionsToString(it.collections) : '');
        setPreviewWins(it ? String(it.wins ?? 0) : '');
        setPreviewLosses(it ? String(it.losses ?? 0) : '');
        setPreviewTourneyCount(it ? String(it.tourneyCount ?? 0) : '');
        setPreviewTourneyWins(it ? String(tourneyWinsFromBonus(it.tourneyBonus || 0)) : '');
        setPreviewAddedAt(it ? toDateTimeLocalValue(it.addedAt) : '');
      },[previewId,items]);

// lazy-load full-res image for preview modal
useEffect(()=>{
  if (!previewId) {
    setPreviewSrc(null);
    return;
  }

  // start with whatever we already have (thumbnail or dataUrl stored in state)
  const current = items.find(x => x.id === previewId);
  const base =
    (current && (current.dataUrl || current.thumbnail)) || null;
  setPreviewSrc(base);

  let cancelled = false;

  (async () => {
    try {
      const full = await idbGet(previewId);
      if (!cancelled && full && full.dataUrl) {
        setPreviewSrc(full.dataUrl);   // swap in the big image
      }
    } catch (e) {
      console.error('Failed to load full preview', e);
    }
  })();

  return () => {
    cancelled = true;
  };
}, [previewId, items]);

      // reset pages when filters/sorts change
      useEffect(()=>{
        setLibraryPage(1);
      },[libraryFilter,libraryCollectionFilter,libraryGeneratorFilter,librarySort,items.length]);
      useEffect(()=>{
        setCollectionPage(1);
      },[activeCollection,activeCollectionType,collectionTabView,items.length,collectionSort]);

      // helpers to persist + update
      async function replaceAllItems(next){
        setItems(next);
        await idbBulkPutMerged(next);
      }
      async function patchItem(id,patch){
        setItems(prev=>{
          const next = prev.map(it=>{
            if(it.id!==id) return it;
            const updated = {...it,...patch};
            idbPutMerged(updated);
            return updated;
          });
          return next;
        });
      }
      async function addNewItems(newItems){
        const nextNumber = getNextImageNumber(items);
        const numberedItems = newItems.map((item, index) => ({
          ...item,
          title: trimTitle(item.title || ''),
          imageNumber: nextNumber + index
        }));
        const merged = [...items, ...numberedItems];
        setItems(merged);
        await idbBulkPut(numberedItems);
        if(merged.length>=2 && (!matchIds[0]||!matchIds[1])){
          const [a,b] = pickTwoFromPool(merged);
          setMatchIds([a,b]);
        }
      }

      // delete with confirm
      async function removeItem(id){
        if(!confirm('Delete this image? This cannot be undone unless you have an export.')) return;
        await idbDelete(id);
        const next = items.filter(it=>it.id!==id);
        setItems(next);
        const nextMatchMode = (matchMode.type==='locked' && matchMode.lockedId===id)
          ? {type:'all', collection:null, generator:null, lockedId:null}
          : matchMode;
        if(nextMatchMode !== matchMode){
          setMatchMode(nextMatchMode);
        }
        const pool = getMatchPool(next,nextMatchMode);
        const [a,b] = (nextMatchMode.type === 'allFlat')
          ? pickTwoFromPoolFlat(pool)
          : nextMatchMode.type === 'generated'
            ? pickTwoFromPoolDifferentGenerators(pool)
            : pickTwoFromPool(pool);
        setMatchIds([a,b]);
        if(previewId===id) setPreviewId(null);
        setSelectedIds(prev=>prev.filter(x=>x!==id));
      }

// Preload the current matchup images so flipping feels snappier
useEffect(() => {
  if (!matchIds || !matchIds[0] || !matchIds[1]) return;
  if (!items || !items.length) return;

  const left  = items.find(it => it.id === matchIds[0]);
  const right = items.find(it => it.id === matchIds[1]);

  const leftSrc  = getMatchupSources(left)[0] || '';
  const rightSrc = getMatchupSources(right)[0] || '';

  preloadImage(leftSrc);
  preloadImage(rightSrc);
}, [matchIds, items]);


function getMatchPool(all,mode){
  let pool = all;

  if(mode.type==='bottom'){
    // Bottom 50% by total matchups
    const sorted = [...all].sort(
      (a,b)=> matchupsCount(a) - matchupsCount(b)
    );
    const cutoff = Math.ceil(sorted.length/2);
    pool = sorted.slice(0,cutoff);

  }else if(mode.type==='bottom25' || mode.type==='bottom10'){
    // Bottom 25% / 10% by total matchups
    const sorted = [...all].sort(
      (a,b)=> matchupsCount(a) - matchupsCount(b)
    );
    const fraction = mode.type==='bottom25' ? 0.25 : 0.10;
    const cutoff = Math.max(2, Math.ceil(sorted.length * fraction));
    pool = sorted.slice(0, cutoff);

  }else if(
    mode.type==='topWinPct10' ||
    mode.type==='topWinPct25' ||
    mode.type==='topWinPct50' ||
    mode.type==='bottomWinPct10'
  ){
    // Top/Bottom win% pools
    const sorted = [...all].sort((a,b)=>{
      const pa = pct(a.wins||0, a.losses||0);
      const pb = pct(b.wins||0, b.losses||0);

      if(pa !== pb){
        // For top: highest first. For bottom: lowest first.
        return mode.type === 'bottomWinPct10' ? (pa - pb) : (pb - pa);
      }

      // Tie-breaker: use matchups
      const ma = matchupsCount(a);
      const mb = matchupsCount(b);
      return mode.type === 'bottomWinPct10' ? (ma - mb) : (mb - ma);
    });

    const winPctFractions = {
      topWinPct10: 0.10,
      topWinPct25: 0.25,
      topWinPct50: 0.50,
      bottomWinPct10: 0.10
    };
    const fraction = winPctFractions[mode.type] ?? 0.10;
    const cutoff = Math.max(2, Math.ceil(sorted.length * fraction));
    pool = sorted.slice(0, cutoff);

  }else if(mode.type==='collection' && mode.collection){
    pool = all.filter(it=> (it.collections||[]).includes(mode.collection));

  }else if(mode.type==='generator' && mode.generator){
    pool = all.filter(it=>{
      const gen = (it.generator || '').trim();
      if(mode.generator==='Unspecified'){
        return !gen;
      }
      return gen === mode.generator;
    });

  }else if(mode.type==='locked'){
    pool = all;

} else if(mode.type==='freshLeaf'){
  // Only images that would show the üå± icon ("fresh")
  // New = fewer than 4 matchups (M < 4)
  pool = all.filter(it=> matchupsCount(it) < 4);
}

  // Fallback safety
  if(pool.length<2) pool = all;
  return pool;
}




function rerollMatch(poolOverride){
      const pool = poolOverride || getMatchPool(items,matchMode);
      const [a,b] = (matchMode.type === 'locked')
        ? pickLockedMatch(pool, matchMode.lockedId)
        : (matchMode.type === 'allFlat')
          ? pickTwoFromPoolFlat(pool)
          : matchMode.type === 'generated'
            ? pickTwoFromPoolDifferentGenerators(pool)
            : pickTwoFromPool(pool);
      setMatchIds([a,b]);
    }


// file handling

async function handleFiles(fileList, forcedCollections = null, forcedGenerator = null){
  const arr = Array.from(fileList || []);
  if (!arr.length) return;

  const processed = [];

  for (const file of arr){
    const id = createId();

    // Full-size compressed image (same as before, max ~1300px)
    const dataUrl = await fileToCompressedDataUrl(file, 1500);

    // NEW: smaller thumbnail (around 320px)
    const thumbDataUrl = await fileToCompressedDataUrl(file, 480);

    processed.push({
      id,
      title: trimTitle(file.name.replace(/\.[^.]+$/,'')),
      generator: forcedGenerator || '',
      collections: forcedCollections || [],
      wins: 0,
      losses: 0,
      tourneyBonus: 0,
      tourneyCount: 0,
      dataUrl,        // full-size compressed
      thumbnail: thumbDataUrl, // rename to our unified field
      addedAt: nowStamp(),
      hasBeenExported: false,
      lastExportedAt: null
    });
  }

  await addNewItems(processed);
}



      // ---------- BADGE MAP (includes Tournament Champion badge) ----------
      const badgeMap = useMemo(()=>{
        const map = new Map();
        if(!items.length) return map;
        const ptsValues = Array.from(
          new Set(items.map(it=>computePoints(it.wins,it.losses,it.tourneyBonus||0)))
        ).sort((a,b)=>b-a);
        const goldPts = ptsValues[0];
        const silverPts = ptsValues[1];
        const bronzePts = ptsValues[2];
        for(const it of items){
          const pts = computePoints(it.wins,it.losses,it.tourneyBonus||0);
          const m = matchupsCount(it);
          const wins = it.wins||0;
          const losses = it.losses||0;
          const b = {};
          if(ptsValues.length>0 && pts===goldPts) b.gold = true;
          if(ptsValues.length>1 && pts===silverPts) b.silver = true;
          if(ptsValues.length>2 && pts===bronzePts) b.bronze = true;
          if(m < 4) b.fresh = true;
          if(wins >= 3 && losses === 0) b.undefeated = true;
          if(losses >= 3 && wins === 0) b.winless = true;
          const tourneyWins = tourneyWinsFromBonus(it.tourneyBonus || 0);
          if(tourneyWins > 0) b.champion = true;
          if(tourneyWins > 0) b.tourneyWins = tourneyWins;
          if(Object.keys(b).length>0){
            map.set(it.id,b);
          }
        }
        return map;
      },[items]);

      const topPointsRanking = useMemo(()=>{
        const ranked = items.map(it=>({
          id: it.id,
          item: it,
          points: computePoints(it.wins,it.losses,it.tourneyBonus||0),
          wins: it.wins || 0,
          matchups: matchupsCount(it)
        }));
        ranked.sort((a,b)=>{
          if(b.points !== a.points) return b.points - a.points;
          if(b.wins !== a.wins) return b.wins - a.wins;
          if(b.matchups !== a.matchups) return b.matchups - a.matchups;
          return String(a.id).localeCompare(String(b.id));
        });
        return ranked.slice(0,25).map((entry,index)=>({
          ...entry,
          rank: index + 1
        }));
      },[items]);

      function clearRankNoticeTimers(){
        if(rankNoticeTimers.current.hide){
          clearTimeout(rankNoticeTimers.current.hide);
        }
        if(rankNoticeTimers.current.clear){
          clearTimeout(rankNoticeTimers.current.clear);
        }
        rankNoticeTimers.current.hide = null;
        rankNoticeTimers.current.clear = null;
      }

      function showRankNotice(changes){
        clearRankNoticeTimers();
        if(!changes.length) return;
        setRankNotice({changes});
        setRankNoticeVisible(true);
        rankNoticeTimers.current.hide = setTimeout(()=>setRankNoticeVisible(false), 10000);
        rankNoticeTimers.current.clear = setTimeout(()=>setRankNotice(null), 10600);
      }

      function loadRankNoticeFeed(){
        if(typeof localStorage === 'undefined') return [];
        try{
          const raw = localStorage.getItem(rankNoticeStorageKey);
          if(!raw) return [];
          const parsed = JSON.parse(raw);
          if(Array.isArray(parsed)) return parsed;
        }catch(err){
          console.warn('Failed to load rank notice feed', err);
        }
        return [];
      }

      function saveRankNoticeFeed(entries){
        if(typeof localStorage === 'undefined') return;
        try{
          localStorage.setItem(rankNoticeStorageKey, JSON.stringify(entries));
        }catch(err){
          console.warn('Failed to save rank notice feed', err);
        }
      }

      function appendRankNoticeFeed(changes){
        const existing = loadRankNoticeFeed();
        const now = new Date().toISOString();
        const next = [
          ...changes.map(change => ({
            id: change.id,
            message: change.message,
            createdAt: now
          })),
          ...existing
        ];
        saveRankNoticeFeed(next.slice(0, 500));
      }

      useEffect(()=>{
        return ()=>clearRankNoticeTimers();
      },[]);

      useEffect(()=>{
        if(!topPointsRanking.length){
          topPointsPrevRef.current = null;
          return;
        }
        if(!topPointsPrevRef.current){
          topPointsPrevRef.current = topPointsRanking;
          return;
        }
        const prev = topPointsPrevRef.current;
        const prevById = new Map(prev.map(entry=>[entry.id, entry]));
        const nextById = new Map(topPointsRanking.map(entry=>[entry.id, entry]));
        const affected = [];
        const seen = new Set();
        const rankingChanged = prev.length !== topPointsRanking.length
          || prev.some((entry, index) => !topPointsRanking[index] || topPointsRanking[index].id !== entry.id);

        const addChange = (entry, message)=>{
          if(!entry || seen.has(entry.id)) return;
          seen.add(entry.id);
          affected.push({
            id: entry.id,
            item: entry.item,
            message
          });
        };

        for(const entry of topPointsRanking){
          const prevEntry = prevById.get(entry.id);
          if(prevEntry && prevEntry.rank !== entry.rank){
            if(entry.rank < prevEntry.rank){
              const displaced = prev[entry.rank - 1];
              if(displaced && displaced.id !== entry.id){
                addChange(entry, `ID ${entry.id} took the #${entry.rank} spot away from ID ${displaced.id}!!`);
              }else{
                addChange(entry, `ID ${entry.id} climbed to #${entry.rank} from #${prevEntry.rank}.`);
              }
            }else{
              const usurper = topPointsRanking[prevEntry.rank - 1];
              if(usurper && usurper.id !== entry.id){
                addChange(entry, `ID ${entry.id} lost the #${prevEntry.rank} spot to ID ${usurper.id}.`);
              }else{
                addChange(entry, `ID ${entry.id} slid down to #${entry.rank} from #${prevEntry.rank}.`);
              }
            }
          }
        }

        for(const prevEntry of prev){
          if(!nextById.has(prevEntry.id)){
            addChange(prevEntry, `ID ${prevEntry.id} dropped out of the top 25 from #${prevEntry.rank}.`);
          }
        }

        for(const entry of topPointsRanking){
          if(!prevById.has(entry.id)){
            addChange(entry, `ID ${entry.id} entered the top 25 at #${entry.rank}.`);
          }
        }

        if(affected.length && rankingChanged){
          appendRankNoticeFeed(affected);
          showRankNotice(affected);
        }
        topPointsPrevRef.current = topPointsRanking;
      },[topPointsRanking]);

// ---------- BADGE COUNTS SUMMARY ----------
const totalUndefeated = Array.from(badgeMap.values())
  .filter(b => b.undefeated).length;

// üå± "New" = images that have had fewer than 4 matchups
const totalNew = items.filter(it => matchupsCount(it) < 4).length;


const totalWinless = Array.from(badgeMap.values())
  .filter(b => b.winless).length;


      function renderBadges(id, placement='badgeRow-top-right'){
        const b = badgeMap.get(id);
        if(!b) return null;
        const trophyCount = Math.max(0, Number(b.tourneyWins || 0));
        const trophyBadges = trophyCount > 0 ? 'üèÜ'.repeat(trophyCount) : '';
        return (
          <div className={'badgeRow '+placement}>
            {trophyBadges && <span className="badge gold">{trophyBadges}</span>}
            {b.gold && <span className="badge gold">ü•á</span>}
            {b.silver && <span className="badge silver">ü•à</span>}
            {b.bronze && <span className="badge bronze">ü•â</span>}
            {b.undefeated && <span className="badge undefeated">‚≠ê</span>}
            {b.winless && <span className="badge winless">üí©</span>}
            {b.fresh && <span className="badge fresh">üå±</span>}
          </div>
        );
      }

      function matchupMedalClass(id){
        const b = badgeMap.get(id);
        if(!b) return '';
        if(b.gold) return 'medal-gold';
        if(b.silver) return 'medal-silver';
        if(b.bronze) return 'medal-bronze';
        return '';
      }

// export/import
async function exportLibrary(){
  // If any images are selected (via gallery checkboxes), export only those.
  // Otherwise, export the entire library.
  const exportItems = selectedIds.length
    ? items.filter(it => selectedIds.includes(it.id))
    : items;

  if(!exportItems.length){
    alert('No images to export. Select some images in the gallery first.');
    return;
  }

  const fullItems = await Promise.all(exportItems.map(async (it) => {
    if(!it || !it.id) return it;
    try{
      const full = await idbGet(it.id);
      return full || it;
    }catch(err){
      console.warn('Failed to hydrate export item', it.id, err);
      return it;
    }
  }));

  // Build and download JSON (full image export)
  const payload = {
    version: 2,
    type: 'library-full',
    exportedAt: new Date().toISOString(),
    items: fullItems,
    generatorCatalog: customGenerators
  };
  const blob = new Blob([JSON.stringify(payload,null,2)],{type:'application/json'});
  const a = document.createElement('a');
  const ts = new Date().toISOString().replace(/[:.]/g,'-');
  a.href = URL.createObjectURL(blob);
  a.download = `modelmatchup-library-${ts}.json`;
  a.click();
  URL.revokeObjectURL(a.href);

  // SAFER: mark exported items without clearing the whole DB
  try{
    const stamp = nowStamp();
    for(const it of exportItems){
      const existing = items.find(x => x.id === it.id);
      const last = existing && existing.lastExportedAt
        ? existing.lastExportedAt
        : stamp;

      // patchItem updates React state + IndexedDB for this one item
      patchItem(it.id, {
        hasBeenExported: true,
        lastExportedAt: last
      });
    }
  }catch(err){
    console.error('Failed to update export flags', err);
    // Even if this fails, your library is still intact.
  }
  // After export: clear any selected images in the gallery
  setSelectedIds([]);
}



// NEW: export metadata ONLY (no dataUrl) for selected or all images
async function exportMetadata(){
  const exportItems = selectedIds.length
    ? items.filter(it => selectedIds.includes(it.id))
    : items;

  if(!exportItems.length){
    alert('No images to export metadata for. Select some images in the gallery first.');
    return;
  }

  const fullItems = await Promise.all(exportItems.map(async (it) => {
    if(!it || !it.id) return it;
    try{
      const full = await idbGet(it.id);
      return full || it;
    }catch(err){
      console.warn('Failed to hydrate metadata item', it.id, err);
      return it;
    }
  }));

  const metaItems = exportItems.map((it, index) => {
    const sourceItem = fullItems[index] || it;
    const badges = badgeMap.get(it.id) || {};
    const badgeNames = Object.keys(badges).filter(k => badges[k]);

    // fingerprint ties this metadata entry to the actual image pixels
    const fingerprintSource =
      (sourceItem && typeof sourceItem.dataUrl === 'string' && sourceItem.dataUrl) ||
      sourceItem?.fullUrl ||
      sourceItem?.thumbnail;
    const fingerprint = (fingerprintSource && typeof fingerprintSource === 'string')
      ? fingerprintSource.slice(0, 120)     // short prefix is enough, keeps file small
      : null;

return {
  id: it.id,
  title: it.title || '',
  imageNumber: it.imageNumber || null,
  generator: it.generator || '',
  collections: it.collections || [],
  wins: it.wins || 0,
  losses: it.losses || 0,
  tourneyBonus: it.tourneyBonus || 0,
  tourneyCount: it.tourneyCount || 0,         // üëà NEW
  points: computePoints(it.wins,it.losses,it.tourneyBonus||0),
  matchups: matchupsCount(it),
  addedAt: it.addedAt || null,
  badges: badgeNames,
  fingerprint
};

  });

  const payload = {
    version: 6,
    type: 'metadata-only',
    exportedAt: new Date().toISOString(),
    items: metaItems,
    collectionGroups: normalizeCollectionGroupsForExport(collectionGroups, allCollectionNames),
    generatorGroups: normalizeGeneratorGroupsForExport(generatorGroups, allGeneratorNames),
    generatorCatalog: customGenerators
  };
  const blob = new Blob([JSON.stringify(payload,null,2)],{type:'application/json'});
  const a = document.createElement('a');
  const ts = new Date().toISOString().replace(/[:.]/g,'-');
  a.href = URL.createObjectURL(blob);
  a.download = `modelmatchup-metadata-${ts}.json`;
  a.click();
  URL.revokeObjectURL(a.href);
  // After metadata export: clear the selection too
  setSelectedIds([]);
}


      function selectUnexported(){
        const ids = items
          .filter(it => !it.hasBeenExported)
          .map(it => it.id);

        if(!ids.length){
          alert('No unexported images in the library.');
          return;
        }
        setSelectedIds(ids);
      }

// NEW: import multiple JSON files at once.
// If files contain dataUrl, treat as full exports (images + metadata).
// If they don't, treat as metadata-only updates (stats, titles, collections, etc.).

// NEW: thumbnail generation helper
async function generateMissingThumbnails(){
  const ok = confirm(
    "This will generate thumbnails in small batches so the browser doesn't crash.\n\n" +
    "You may need to run it a few times until it reports 0 new thumbnails."
  );
  if (!ok) return;

  try {
    const count = await generateMissingThumbnails_Safe((status) => {
      console.log(status);
    });

    let fresh = [];
    try {
      fresh = await loadOptimizedLibrary();
    } catch (e) {
      console.error('loadOptimizedLibrary failed after thumbnail generation, falling back to idbGetAll', e);
      fresh = await idbGetAll();
    }

    const norm = fresh.map(it => ({
      ...it,
      title: it.title || '',
      generator: it.generator || '',
      collections: normalizeCollections(it.collections || it.collectionsRaw || ''),
      wins: Number(it.wins || 0),
      losses: Number(it.losses || 0),
      tourneyBonus: Number(it.tourneyBonus || 0),
      tourneyCount: Number(it.tourneyCount || 0),
      addedAt: it.addedAt || nowStamp(),
      hasBeenExported: !!it.hasBeenExported,
      lastExportedAt: it.lastExportedAt || null,
      thumbnail: it.thumbnail || it.thumbDataUrl || null,
      dataUrl: it.dataUrl || null
    }));

    setItems(norm);
    alert(`Generated thumbnails for ${count} images in this batch.`);
  } catch (e) {
    console.error('generateMissingThumbnails failed', e);
    alert('Failed to generate thumbnails: ' + (e && e.message ? e.message : String(e)));
  }
}





async function importLibraryFiles(fileList){
  try{
    const files = Array.from(fileList || []);
    if(!files.length) return;

    // ---- 1. Peek at the first file to decide mode ----
    const firstFile = files[0];
    const firstText = await firstFile.text();
    const firstJson = JSON.parse(firstText);

if(!firstJson.items || !Array.isArray(firstJson.items)){
  throw new Error(`Bad file format in ${firstFile.name}`);
}

const firstItems = firstJson.items;
const fileType = firstJson.type || null;

// Detect export mode safely (works for fullUrl-only exports too)
const sample = firstItems.slice(0, 300);
const hasAnyImagePayload = sample.some(it =>
  (typeof it.dataUrl === 'string' && it.dataUrl.length > 50) ||
  (typeof it.fullUrl === 'string' && it.fullUrl.trim().length > 0) ||
  (typeof it.mediumUrl === 'string' && it.mediumUrl.trim().length > 0) ||
  (typeof it.thumbUrl === 'string' && it.thumbUrl.trim().length > 0) ||
  (typeof it.thumbnail === 'string' && it.thumbnail.trim().length > 0) ||
  (typeof it.thumbDataUrl === 'string' && it.thumbDataUrl.trim().length > 50)
);

const isMetadataOnly = fileType === 'metadata-only' || (!fileType && !hasAnyImagePayload);
const isFullExport   = fileType === 'library-full' || (!isMetadataOnly && hasAnyImagePayload);
const importedGroupDefs = Array.isArray(firstJson.collectionGroups) ? [...firstJson.collectionGroups] : [];
const importedGeneratorGroupDefs = Array.isArray(firstJson.generatorGroups) ? [...firstJson.generatorGroups] : [];
const importedGeneratorCatalog = Array.isArray(firstJson.generatorCatalog) ? [...firstJson.generatorCatalog] : [];


    // ======================================================
    // PATH A: FULL EXPORT IMPORT (images + metadata)
    // ======================================================
    if(isFullExport){
      let totalImported = 0;
      let nextImageNumber = getNextImageNumber(items);

      // Helper to normalize + write one items array to DB in chunks
      async function importItemsArray(itemsArr){
        if(!Array.isArray(itemsArr) || !itemsArr.length) return;

        const cleaned = itemsArr.map(it => ({
          ...it,
          id: it.id || createId(),
          title: trimTitle(typeof it.title === 'string' ? it.title : ''),
          imageNumber: nextImageNumber++,

          // unify / normalize thumbnail field
          thumbnail: it.thumbnail || it.thumbDataUrl || null,

          collections: normalizeCollections(it.collections || ''),

          wins: Number(it.wins || 0),
          losses: Number(it.losses || 0),
          tourneyBonus: Number(it.tourneyBonus || 0),
          tourneyCount: Number(it.tourneyCount || 0),

          addedAt: it.addedAt || nowStamp(),
          hasBeenExported: !!it.hasBeenExported,
          lastExportedAt: it.lastExportedAt || null
        }));

        const CHUNK = 10;
        for(let i = 0; i < cleaned.length; i += CHUNK){
          const chunk = cleaned.slice(i, i + CHUNK);
          await idbBulkPut(chunk);
        }

        totalImported += cleaned.length;
      }

      // process FIRST file
      await importItemsArray(firstItems);

      // process REMAINING files one-by-one (no big parsedFiles array)
      for(let idx = 1; idx < files.length; idx++){
        const f = files[idx];
        const text = await f.text();
        const json = JSON.parse(text);

        if(!json.items || !Array.isArray(json.items)){
          throw new Error(`Bad file format in ${f.name}`);
        }
        if(Array.isArray(json.generatorCatalog)){
          importedGeneratorCatalog.push(...json.generatorCatalog);
        }
        await importItemsArray(json.items);
      }

      // Reload a lightweight, thumbnail-only view into React state
      const lib = await loadOptimizedLibrary();
      setItems(lib);
      if(importedGroupDefs.length){
        setCollectionGroups(mergeCollectionGroups(importedGroupDefs));
      }
      if(importedGeneratorGroupDefs.length){
        setGeneratorGroups(mergeGeneratorGroups(importedGeneratorGroupDefs));
      }
      if(importedGeneratorCatalog.length){
        const mergedCatalog = mergeGeneratorCatalog(loadGeneratorCatalog(), importedGeneratorCatalog);
        persistGeneratorCatalog(mergedCatalog);
        setCustomGenerators(mergedCatalog);
      }

      alert(`Import complete. Added ${totalImported} images.`);
      return;
    }

    // ======================================================
    // PATH B: METADATA-ONLY IMPORT (no dataUrl)
    // ======================================================

    // Build lookup maps without ever touching React state
    const { byId, byFingerprint } = await getSmartLookupMap();

// Collect metadata entries from ALL files (these are tiny)
const allImportedMeta = [...firstItems];

for (let idx = 1; idx < files.length; idx++) {
  const f = files[idx];
  const text = await f.text();
  const json = JSON.parse(text);

  if (!json.items || !Array.isArray(json.items)) {
    throw new Error(`Bad file format in ${f.name}`);
  }
  allImportedMeta.push(...json.items);
  if(Array.isArray(json.collectionGroups)){
    importedGroupDefs.push(...json.collectionGroups);
  }
  if(Array.isArray(json.generatorGroups)){
    importedGeneratorGroupDefs.push(...json.generatorGroups);
  }
  if(Array.isArray(json.generatorCatalog)){
    importedGeneratorCatalog.push(...json.generatorCatalog);
  }
}


    const updatesToApply = [];
    const mergedImportedGroups = mergeCollectionGroups(importedGroupDefs);
    const mergedImportedGeneratorGroups = mergeGeneratorGroups(importedGeneratorGroupDefs);

    for(const it of allImportedMeta){
      let targetId = null;

      // 1) direct id match (same device / same DB id)
      if(it.id && byId.has(it.id)){
        targetId = it.id;
      }
      // 2) fingerprint match (cross-device sync)
      else if(it.fingerprint && byFingerprint.has(it.fingerprint)){
        targetId = byFingerprint.get(it.fingerprint);
      }

      if(targetId){
        updatesToApply.push({ targetId, meta: it });
      }
    }

    if(!updatesToApply.length){
      alert('No matching images found to update.');
      return;
    }

    // ---- 2. Apply updates to IndexedDB in small batches ----
    let db;
    try{
      db = await openDB();
    }catch(err){
      console.warn('IndexedDB unavailable, cannot update metadata.', err);
      alert('IndexedDB is unavailable in this browser, so metadata updates cannot be applied.');
      return;
    }
    const BATCH_SIZE = 20;
    let totalUpdated = 0;

    for(let i = 0; i < updatesToApply.length; i += BATCH_SIZE){
      const batch = updatesToApply.slice(i, i + BATCH_SIZE);
      const tx = db.transaction(DB_STORE, 'readwrite');
      const store = tx.objectStore(DB_STORE);

      // Grab existing records for this batch
      const currentImages = await Promise.all(
        batch.map(item =>
          new Promise((resolve, reject) => {
            const req = store.get(item.targetId);
            req.onsuccess = () => resolve(req.result || null);
            req.onerror = () => reject(req.error);
          })
        )
      );

      for(let j = 0; j < batch.length; j++){
        const { targetId, meta } = batch[j];
        const existing = currentImages[j];
        if(!existing) continue;

        const incoming = meta || {};

        const updated = {
          ...existing,
          title: typeof incoming.title === 'string'
            ? incoming.title
            : (existing.title || ''),
          generator: typeof incoming.generator === 'string'
            ? incoming.generator
            : (existing.generator || ''),

          collections: incoming.collections != null
            ? normalizeCollections(incoming.collections)
            : normalizeCollections(existing.collections || []),

          wins: incoming.wins != null
            ? Number(incoming.wins)
            : Number(existing.wins || 0),

          losses: incoming.losses != null
            ? Number(incoming.losses)
            : Number(existing.losses || 0),

          tourneyBonus: incoming.tourneyBonus != null
            ? Number(incoming.tourneyBonus)
            : Number(existing.tourneyBonus || 0),

          tourneyCount: incoming.tourneyCount != null
            ? Number(incoming.tourneyCount)
            : Number(existing.tourneyCount || 0),

          // Keep image blobs as-is
          dataUrl: existing.dataUrl,
          thumbnail: existing.thumbnail || existing.thumbDataUrl || null
        };

        store.put(updated);
      }

      await new Promise((resolve, reject) => {
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
      });

      totalUpdated += batch.length;
    }

    // ---- 3. Mirror those changes into React state (thumb-only) ----
    setItems(prev => {
      const updatesMap = new Map();
      updatesToApply.forEach(u => updatesMap.set(u.targetId, u.meta));

      return prev.map(existing => {
        const incoming = updatesMap.get(existing.id);
        if(!incoming) return existing;

        return {
          ...existing,
          title: typeof incoming.title === 'string'
            ? incoming.title
            : (existing.title || ''),
          generator: typeof incoming.generator === 'string'
            ? incoming.generator
            : (existing.generator || ''),

          collections: incoming.collections != null
            ? normalizeCollections(incoming.collections)
            : normalizeCollections(existing.collections || []),

          wins: incoming.wins != null
            ? Number(incoming.wins)
            : Number(existing.wins || 0),

          losses: incoming.losses != null
            ? Number(incoming.losses)
            : Number(existing.losses || 0),

          tourneyBonus: incoming.tourneyBonus != null
            ? Number(incoming.tourneyBonus)
            : Number(existing.tourneyBonus || 0),

          tourneyCount: incoming.tourneyCount != null
            ? Number(incoming.tourneyCount)
            : Number(existing.tourneyCount || 0)
        };
      });
    });

    if(mergedImportedGroups.length){
      setCollectionGroups(mergeCollectionGroups(mergedImportedGroups));
    }
    if(mergedImportedGeneratorGroups.length){
      setGeneratorGroups(mergeGeneratorGroups(mergedImportedGeneratorGroups));
    }
    if(importedGeneratorCatalog.length){
      const mergedCatalog = mergeGeneratorCatalog(loadGeneratorCatalog(), importedGeneratorCatalog);
      persistGeneratorCatalog(mergedCatalog);
      setCustomGenerators(mergedCatalog);
    }

    alert(`Metadata sync complete. Updated ${totalUpdated} images.`);
  }catch(e){
    console.error(e);
    alert('Import failed: ' + (e && e.message ? e.message : e));
  }
}



    // --- END PASTE ---

      async function resetAllStats(){
        if(!confirm('Reset wins/losses for all images?')) return;
        const next = items.map(it=>({...it,wins:0,losses:0}));
        await replaceAllItems(next);
        setLastMatch(null);
        const pool = getMatchPool(next,matchMode);
        rerollMatch(pool);

      }
      async function clearLibrary(){
        if(!confirm('Delete ALL images from this device? This cannot be undone unless you have an export.')) return;
        await idbClear();
        setItems([]);
        setMatchIds([null,null]);
        setLastMatch(null);
        setSelectedIds([]);
        setPreviewId(null);
      }

      // match result + undo
      function recordWin(winnerId){
        const [a,b] = matchIds;
        if(!a || !b) return;
        const loserId = winnerId===a ? b : a;
        const winner = items.find(it=>it.id===winnerId);
        const loser = items.find(it=>it.id===loserId);
        if(!winner || !loser) return;
        const wWins = (winner.wins||0)+1;
        const lLoss = (loser.losses||0)+1;
        patchItem(winnerId,{wins:wWins});
        patchItem(loserId,{losses:lLoss});
        setLastMatch({winnerId,loserId,leftId:a,rightId:b});
        const pool = getMatchPool(items,matchMode);
        rerollMatch(pool);
      }

      function undoLast(){
        if(!lastMatch) return;
        const {winnerId,loserId,leftId,rightId} = lastMatch;
        const winner = items.find(it=>it.id===winnerId);
        const loser = items.find(it=>it.id===loserId);
        if(winner){
          patchItem(winnerId,{wins:Math.max(0,(winner.wins||0)-1)});
        }
        if(loser){
          patchItem(loserId,{losses:Math.max(0,(loser.losses||0)-1)});
        }
        setMatchIds([leftId,rightId]);
        setLastMatch(null);
      }

      // all collection names
      const allCollectionNames = useMemo(()=>{
        const set = new Set();
        for(const it of items){
          (it.collections||[]).forEach(c=>c && set.add(c));
        }
        return Array.from(set).sort((a,b)=>a.localeCompare(b));
      },[items]);
      const allGeneratorNames = useMemo(()=>{
        const set = new Set(customGenerators);
        for(const it of items){
          const name = (it.generator || '').trim() || 'Unspecified';
          set.add(name);
        }
        return Array.from(set).sort((a,b)=>a.localeCompare(b));
      },[items, customGenerators]);
      const generatorSelectOptions = useMemo(()=>{
        const names = allGeneratorNames.filter(name=>name && name !== 'Unspecified');
        return [
          {label:'Unspecified', value:''},
          ...names.map(name=>({label:name, value:name}))
        ];
      },[allGeneratorNames]);

      useEffect(()=>{
        if(typeof window==='undefined') return;
        const handleStorage = (event)=>{
          if(event.key === 'generatorCatalog'){
            setCustomGenerators(loadGeneratorCatalog());
          }
        };
        window.addEventListener('storage', handleStorage);
        return ()=>window.removeEventListener('storage', handleStorage);
      },[]);

      const groupedCollectionNames = useMemo(()=>{
        const set = new Set();
        for(const group of collectionGroups){
          (group.members||[]).forEach(name=>name && set.add(name));
        }
        return set;
      },[collectionGroups]);

      const collectionGroupLookup = useMemo(()=>{
        const map = {};
        for(const group of collectionGroups){
          (group.members||[]).forEach(name=>{
            if(name){
              map[name] = group.id;
            }
          });
        }
        return map;
      },[collectionGroups]);
      const generatorGroupLookup = useMemo(()=>{
        const map = {};
        for(const group of generatorGroups){
          (group.members||[]).forEach(name=>{
            if(name){
              map[name] = group.id;
            }
          });
        }
        return map;
      },[generatorGroups]);

      const collectionGroupMembersMap = useMemo(()=>{
        const map = {};
        for(const group of collectionGroups){
          map[group.id] = (group.members || []).filter(Boolean);
        }
        return map;
      },[collectionGroups]);
      const generatorGroupMembersMap = useMemo(()=>{
        const map = {};
        for(const group of generatorGroups){
          map[group.id] = (group.members || []).filter(Boolean);
        }
        return map;
      },[generatorGroups]);

      const ungroupedCollections = useMemo(()=>{
        return allCollectionNames.filter(name=>!groupedCollectionNames.has(name));
      },[allCollectionNames, groupedCollectionNames]);
      const groupedGeneratorNames = useMemo(()=>{
        const set = new Set();
        for(const group of generatorGroups){
          (group.members||[]).forEach(name=>name && set.add(name));
        }
        return set;
      },[generatorGroups]);
      const ungroupedGenerators = useMemo(()=>{
        return allGeneratorNames.filter(name=>!groupedGeneratorNames.has(name));
      },[allGeneratorNames, groupedGeneratorNames]);

      useEffect(()=>{
        if(typeof localStorage==='undefined') return;
        try{
          localStorage.setItem('collectionGroups', JSON.stringify({groups: collectionGroups}));
        }catch(err){
          console.warn('Failed to persist collection groups', err);
        }
      },[collectionGroups]);
      useEffect(()=>{
        if(typeof localStorage==='undefined') return;
        try{
          localStorage.setItem('generatorGroups', JSON.stringify({groups: generatorGroups}));
        }catch(err){
          console.warn('Failed to persist generator groups', err);
        }
      },[generatorGroups]);

      useEffect(()=>{
        if(!libraryHydrated) return;
        const allowed = new Set(allCollectionNames);
        setCollectionGroups(prev=>{
          if(allowed.size === 0) return prev;
          let changed = false;
          const next = prev.map(group=>{
            const filtered = (group.members || []).filter(name=>allowed.has(name));
            const deduped = Array.from(new Set(filtered));
            const same = deduped.length === (group.members||[]).length && deduped.every((m,idx)=>m === (group.members||[])[idx]);
            if(!same) changed = true;
            return {...group, members: deduped};
          });
          return changed ? next : prev;
        });
      },[allCollectionNames, libraryHydrated]);
      useEffect(()=>{
        if(!libraryHydrated) return;
        const allowed = new Set(allGeneratorNames);
        setGeneratorGroups(prev=>{
          if(allowed.size === 0) return prev;
          let changed = false;
          const next = prev.map(group=>{
            const filtered = (group.members || []).filter(name=>allowed.has(name));
            const deduped = Array.from(new Set(filtered));
            const same = deduped.length === (group.members||[]).length && deduped.every((m,idx)=>m === (group.members||[])[idx]);
            if(!same) changed = true;
            return {...group, members: deduped};
          });
          return changed ? next : prev;
        });
      },[allGeneratorNames, libraryHydrated]);

      useEffect(()=>{
        const validIds = new Set(collectionGroups.map(g=>g.id));
        setLibraryCollectionFilter(prev=>{
          const includeGroups = (prev.includeGroups || []).filter(id=>validIds.has(id));
          const excludeGroups = (prev.excludeGroups || []).filter(id=>validIds.has(id));
          if(includeGroups.length===(prev.includeGroups||[]).length && excludeGroups.length===(prev.excludeGroups||[]).length){
            return prev;
          }
          return {...prev, includeGroups, excludeGroups};
        });
      },[collectionGroups]);
      useEffect(()=>{
        const validIds = new Set(collectionGroups.map(g=>g.id));
        setCollectionStatsFilter(prev=>{
          const includeGroups = (prev.includeGroups || []).filter(id=>validIds.has(id));
          const excludeGroups = (prev.excludeGroups || []).filter(id=>validIds.has(id));
          if(includeGroups.length===(prev.includeGroups||[]).length && excludeGroups.length===(prev.excludeGroups||[]).length){
            return prev;
          }
          return {...prev, includeGroups, excludeGroups};
        });
      },[collectionGroups]);
      useEffect(()=>{
        const validIds = new Set(generatorGroups.map(g=>g.id));
        setLibraryGeneratorFilter(prev=>{
          const includeGroups = (prev.includeGroups || []).filter(id=>validIds.has(id));
          const excludeGroups = (prev.excludeGroups || []).filter(id=>validIds.has(id));
          if(includeGroups.length===(prev.includeGroups||[]).length && excludeGroups.length===(prev.excludeGroups||[]).length){
            return prev;
          }
          return {...prev, includeGroups, excludeGroups};
        });
      },[generatorGroups]);

      function createCollectionGroup(){
        const name = prompt('Name for the new group?');
        if(!name) return;
        const clean = name.trim();
        if(!clean) return;
        setCollectionGroups(prev=>{
          if(prev.some(g=>g.name.toLowerCase()===clean.toLowerCase())){
            alert('That group name already exists.');
            return prev;
          }
          return [...prev,{
            id: createId(),
            name: clean,
            members: [],
            open: true
          }];
        });
      }

      function toggleGroupOpen(id){
        setCollectionGroups(prev=>prev.map(g=>g.id===id ? {...g, open: !g.open} : g));
      }

      function moveCollectionToGroup(name,targetGroupId){
        setCollectionGroups(prev=>{
          let changed = false;
          const next = prev.map(g=>{
            const original = g.members || [];
            let members = original.filter(m=>m!==name);
            if(targetGroupId && g.id===targetGroupId && !members.includes(name)){
              members = [...members, name].sort((a,b)=>a.localeCompare(b));
            }
            const same = members.length===original.length && members.every((m,idx)=>m===original[idx]);
            if(!same) changed = true;
            return {...g, members};
          });
          return changed ? next : prev;
        });
      }

      function cycleCollectionFilter(name){
        setLibraryCollectionFilter(prev=>{
          const inc = new Set(prev.include || []);
          const exc = new Set(prev.exclude || []);
          const includeGroups = prev.includeGroups || [];
          const excludeGroups = prev.excludeGroups || [];
          const mode = prev.mode || 'all';
          if(!inc.has(name) && !exc.has(name)){
            inc.add(name);
          }else if(inc.has(name)){
            inc.delete(name);
            exc.add(name);
          }else if(exc.has(name)){
            exc.delete(name);
          }
          return {
            include: [...inc],
            exclude: [...exc],
            includeGroups: [...includeGroups],
            excludeGroups: [...excludeGroups],
            mode
          };
        });
      }

      function cycleCollectionGroupFilter(groupId){
        setLibraryCollectionFilter(prev=>{
          const inc = new Set(prev.includeGroups || []);
          const exc = new Set(prev.excludeGroups || []);
          const include = prev.include || [];
          const exclude = prev.exclude || [];
          const mode = prev.mode || 'all';
          if(!inc.has(groupId) && !exc.has(groupId)){
            inc.add(groupId);
          }else if(inc.has(groupId)){
            inc.delete(groupId);
            exc.add(groupId);
          }else if(exc.has(groupId)){
            exc.delete(groupId);
          }
          return {
            include,
            exclude,
            includeGroups: [...inc],
            excludeGroups: [...exc],
            mode
          };
        });
      }

      function cycleCollectionStatsFilter(name){
        setCollectionStatsFilter(prev=>{
          const inc = new Set(prev.include || []);
          const exc = new Set(prev.exclude || []);
          const includeGroups = prev.includeGroups || [];
          const excludeGroups = prev.excludeGroups || [];
          if(!inc.has(name) && !exc.has(name)){
            inc.add(name);
          }else if(inc.has(name)){
            inc.delete(name);
            exc.add(name);
          }else if(exc.has(name)){
            exc.delete(name);
          }
          return {
            include: [...inc],
            exclude: [...exc],
            includeGroups: [...includeGroups],
            excludeGroups: [...excludeGroups]
          };
        });
      }

      function cycleCollectionStatsGroupFilter(groupId){
        setCollectionStatsFilter(prev=>{
          const inc = new Set(prev.includeGroups || []);
          const exc = new Set(prev.excludeGroups || []);
          const include = prev.include || [];
          const exclude = prev.exclude || [];
          if(!inc.has(groupId) && !exc.has(groupId)){
            inc.add(groupId);
          }else if(inc.has(groupId)){
            inc.delete(groupId);
            exc.add(groupId);
          }else if(exc.has(groupId)){
            exc.delete(groupId);
          }
          return {
            include,
            exclude,
            includeGroups: [...inc],
            excludeGroups: [...exc]
          };
        });
      }

      function cycleStatsCollectionFilter(name){
        setStatsCollectionFilter(prev=>{
          const inc = new Set(prev.include || []);
          const exc = new Set(prev.exclude || []);
          const includeGroups = prev.includeGroups || [];
          const excludeGroups = prev.excludeGroups || [];
          const mode = prev.mode || 'all';
          if(!inc.has(name) && !exc.has(name)){
            inc.add(name);
          }else if(inc.has(name)){
            inc.delete(name);
            exc.add(name);
          }else if(exc.has(name)){
            exc.delete(name);
          }
          return {
            include: [...inc],
            exclude: [...exc],
            includeGroups: [...includeGroups],
            excludeGroups: [...excludeGroups],
            mode
          };
        });
      }

      function cycleStatsCollectionGroupFilter(groupId){
        setStatsCollectionFilter(prev=>{
          const inc = new Set(prev.includeGroups || []);
          const exc = new Set(prev.excludeGroups || []);
          const include = prev.include || [];
          const exclude = prev.exclude || [];
          const mode = prev.mode || 'all';
          if(!inc.has(groupId) && !exc.has(groupId)){
            inc.add(groupId);
          }else if(inc.has(groupId)){
            inc.delete(groupId);
            exc.add(groupId);
          }else if(exc.has(groupId)){
            exc.delete(groupId);
          }
          return {
            include,
            exclude,
            includeGroups: [...inc],
            excludeGroups: [...exc],
            mode
          };
        });
      }

      function createGeneratorGroup(){
        const name = prompt('Name for the new generator group?');
        if(!name) return;
        const clean = name.trim();
        if(!clean) return;
        setGeneratorGroups(prev=>{
          if(prev.some(g=>g.name.toLowerCase()===clean.toLowerCase())){
            alert('That group name already exists.');
            return prev;
          }
          return [...prev,{
            id: createId(),
            name: clean,
            members: [],
            open: true
          }];
        });
      }

      function toggleGeneratorGroupOpen(id){
        setGeneratorGroups(prev=>prev.map(g=>g.id===id ? {...g, open: !g.open} : g));
      }

      function moveGeneratorToGroup(name,targetGroupId){
        setGeneratorGroups(prev=>{
          let changed = false;
          const next = prev.map(g=>{
            const original = g.members || [];
            let members = original.filter(m=>m!==name);
            if(targetGroupId && g.id===targetGroupId && !members.includes(name)){
              members = [...members, name].sort((a,b)=>a.localeCompare(b));
            }
            const same = members.length===original.length && members.every((m,idx)=>m===original[idx]);
            if(!same) changed = true;
            return {...g, members};
          });
          return changed ? next : prev;
        });
      }

      function cycleGeneratorFilter(name){
        setLibraryGeneratorFilter(prev=>{
          const inc = new Set(prev.include || []);
          const exc = new Set(prev.exclude || []);
          const includeGroups = prev.includeGroups || [];
          const excludeGroups = prev.excludeGroups || [];
          const mode = prev.mode || 'all';
          if(!inc.has(name) && !exc.has(name)){
            inc.add(name);
          }else if(inc.has(name)){
            inc.delete(name);
            exc.add(name);
          }else if(exc.has(name)){
            exc.delete(name);
          }
          return {
            include: [...inc],
            exclude: [...exc],
            includeGroups: [...includeGroups],
            excludeGroups: [...excludeGroups],
            mode
          };
        });
      }

      function cycleGeneratorGroupFilter(groupId){
        setLibraryGeneratorFilter(prev=>{
          const inc = new Set(prev.includeGroups || []);
          const exc = new Set(prev.excludeGroups || []);
          const include = prev.include || [];
          const exclude = prev.exclude || [];
          const mode = prev.mode || 'all';
          if(!inc.has(groupId) && !exc.has(groupId)){
            inc.add(groupId);
          }else if(inc.has(groupId)){
            inc.delete(groupId);
            exc.add(groupId);
          }else if(exc.has(groupId)){
            exc.delete(groupId);
          }
          return {
            include,
            exclude,
            includeGroups: [...inc],
            excludeGroups: [...exc],
            mode
          };
        });
      }

      const renderCollectionRow = (name) => {
        const isInclude = libraryCollectionFilter.include.includes(name);
        const isExclude = libraryCollectionFilter.exclude.includes(name);
        let cls = 'ghost';
        if(isInclude) cls = 'secondary';
        if(isExclude) cls = 'danger';
        return (
          <div key={name} className="collectionGroupRow">
            <button
              className={'btn sm '+cls}
              onClick={()=>{ cycleCollectionFilter(name); }}
            >
              {name}
            </button>
            {collectionGroups.length>0 && (
              <select
                className="select sm collectionGroupSelect"
                value={collectionGroupLookup[name] || ''}
                onChange={e=>moveCollectionToGroup(name, e.target.value || null)}
              >
                <option value="">Ungrouped</option>
                {collectionGroups.map(g=>(
                  <option key={g.id} value={g.id}>
                    {collectionGroupLookup[name]===g.id ? `In ${g.name}` : `Move to ${g.name}`}
                  </option>
                ))}
              </select>
            )}
          </div>
        );
      };

      const renderCollectionStatsRow = (name) => {
        const isInclude = collectionStatsFilter.include.includes(name);
        const isExclude = collectionStatsFilter.exclude.includes(name);
        let cls = 'ghost';
        if(isInclude) cls = 'secondary';
        if(isExclude) cls = 'danger';
        return (
          <div key={name} className="collectionGroupRow">
            <button
              className={'btn sm '+cls}
              onClick={()=>{ cycleCollectionStatsFilter(name); }}
            >
              {name}
            </button>
            {collectionGroups.length>0 && (
              <select
                className="select sm collectionGroupSelect"
                value={collectionGroupLookup[name] || ''}
                onChange={e=>moveCollectionToGroup(name, e.target.value || null)}
              >
                <option value="">Ungrouped</option>
                {collectionGroups.map(g=>(
                  <option key={g.id} value={g.id}>
                    {collectionGroupLookup[name]===g.id ? `In ${g.name}` : `Move to ${g.name}`}
                  </option>
                ))}
              </select>
            )}
          </div>
        );
      };

      const renderStatsCollectionRow = (name) => {
        const isInclude = statsCollectionFilter.include.includes(name);
        const isExclude = statsCollectionFilter.exclude.includes(name);
        let cls = 'ghost';
        if(isInclude) cls = 'secondary';
        if(isExclude) cls = 'danger';
        return (
          <div key={name} className="collectionGroupRow">
            <button
              className={'btn sm '+cls}
              onClick={()=>{ cycleStatsCollectionFilter(name); }}
            >
              {name}
            </button>
            {collectionGroups.length>0 && (
              <select
                className="select sm collectionGroupSelect"
                value={collectionGroupLookup[name] || ''}
                onChange={e=>moveCollectionToGroup(name, e.target.value || null)}
              >
                <option value="">Ungrouped</option>
                {collectionGroups.map(g=>(
                  <option key={g.id} value={g.id}>
                    {collectionGroupLookup[name]===g.id ? `In ${g.name}` : `Move to ${g.name}`}
                  </option>
                ))}
              </select>
            )}
          </div>
        );
      };

      const renderGeneratorRow = (name) => {
        const isInclude = libraryGeneratorFilter.include.includes(name);
        const isExclude = libraryGeneratorFilter.exclude.includes(name);
        let cls = 'ghost';
        if(isInclude) cls = 'secondary';
        if(isExclude) cls = 'danger';
        return (
          <div key={name} className="collectionGroupRow">
            <button
              className={'btn sm '+cls}
              onClick={()=>{ cycleGeneratorFilter(name); }}
            >
              {name}
            </button>
            {generatorGroups.length>0 && (
              <select
                className="select sm collectionGroupSelect"
                value={generatorGroupLookup[name] || ''}
                onChange={e=>moveGeneratorToGroup(name, e.target.value || null)}
              >
                <option value="">Ungrouped</option>
                {generatorGroups.map(g=>(
                  <option key={g.id} value={g.id}>
                    {generatorGroupLookup[name]===g.id ? `In ${g.name}` : `Move to ${g.name}`}
                  </option>
                ))}
              </select>
            )}
          </div>
        );
      };

      const galleryColumnOptions = useMemo(()=>columnOptionsForMode(viewportMode), [viewportMode]);

      // stats for collections (also used for matchups dropdown)
      const collectionStats = useMemo(()=>{
        const map = new Map();
        for(const it of items){
          const cols = it.collections || [];
          for(const name of cols){
            if(!name) continue;
            const cur = map.get(name) || {name,wins:0,losses:0,bonus:0,tourneyCount:0,tourneyWins:0,images:new Set(),bestItem:null,bestItemPoints:-Infinity};
            const itemPoints = computePoints(it.wins,it.losses,it.tourneyBonus||0);
            cur.wins += it.wins||0;
            cur.losses += it.losses||0;
            cur.bonus += Number(it.tourneyBonus||0);
            cur.tourneyCount += Number(it.tourneyCount || 0);
            cur.tourneyWins += tourneyWinsFromBonus(it.tourneyBonus || 0);
            cur.images.add(it.id);
            if(!cur.bestItem || itemPoints>cur.bestItemPoints){
              cur.bestItem = it;
              cur.bestItemPoints = itemPoints;
            }
            map.set(name,cur);
          }
        }
        const rows = Array.from(map.values()).map(r=>({
          name: r.name,
          wins: r.wins,
          losses: r.losses,
          imagesCount: r.images.size,
          matchups: r.wins + r.losses,
          tourneyCount: r.tourneyCount,
          tourneyWins: r.tourneyWins,
          pct: pct(r.wins,r.losses),
          points: computePoints(r.wins,r.losses,r.bonus),
          bestItem: r.bestItem
        }));
        rows.sort((a,b)=>{
          const dir = collStatsSort.dir==='asc' ? 1 : -1;
          const f = collStatsSort.field;
          if(f==='name'){return a.name.localeCompare(b.name)*dir;}
          if(f==='imagesCount' || f==='wins' || f==='losses' || f==='matchups' || f==='points' || f==='tourneyCount' || f==='tourneyWins'){
            return (a[f]-b[f])*dir;
          }
          if(f==='pct'){return (a.pct-b.pct)*dir;}
          return 0;
        });
        return rows.reverse();
      },[items,collStatsSort]);

      const filteredCollectionStats = useMemo(()=>{
        let list = collectionStats;
        const include = collectionStatsFilter.include || [];
        const exclude = collectionStatsFilter.exclude || [];
        const includeGroups = collectionStatsFilter.includeGroups || [];
        const excludeGroups = collectionStatsFilter.excludeGroups || [];
        const includeNames = new Set(include);
        const excludeNames = new Set(exclude);
        const includeGroupMembers = new Set();
        includeGroups.forEach(id => {
          (collectionGroupMembersMap[id] || []).forEach(name=>includeGroupMembers.add(name));
        });
        const excludeGroupMembers = new Set();
        excludeGroups.forEach(id => {
          (collectionGroupMembersMap[id] || []).forEach(name=>excludeGroupMembers.add(name));
        });
        if(includeNames.size || includeGroupMembers.size){
          list = list.filter(row => includeNames.has(row.name) || includeGroupMembers.has(row.name));
        }
        if(excludeNames.size || excludeGroupMembers.size){
          list = list.filter(row => !(excludeNames.has(row.name) || excludeGroupMembers.has(row.name)));
        }
        return list;
      },[collectionStats, collectionStatsFilter, collectionGroupMembersMap]);

      const generatorStats = useMemo(()=>{
        const map = new Map();
        for(const it of items){
          const raw = (it.generator || '').trim();
          const name = raw || 'Unspecified';
          const cur = map.get(name) || {name,wins:0,losses:0,bonus:0,images:new Set(),bestItem:null,bestItemPoints:-Infinity};
          const itemPoints = computePoints(it.wins,it.losses,it.tourneyBonus||0);
          cur.wins += it.wins||0;
          cur.losses += it.losses||0;
          cur.bonus += Number(it.tourneyBonus||0);
          cur.images.add(it.id);
          if(!cur.bestItem || itemPoints>cur.bestItemPoints){
            cur.bestItem = it;
            cur.bestItemPoints = itemPoints;
          }
          map.set(name,cur);
        }
        const rows = Array.from(map.values()).map(r=>({
          name: r.name,
          wins: r.wins,
          losses: r.losses,
          imagesCount: r.images.size,
          matchups: r.wins + r.losses,
          pct: pct(r.wins,r.losses),
          points: computePoints(r.wins,r.losses,r.bonus),
          bestItem: r.bestItem
        }));
        rows.sort((a,b)=>{
          const dir = genStatsSort.dir==='asc' ? 1 : -1;
          const f = genStatsSort.field;
          if(f==='name'){return a.name.localeCompare(b.name)*dir;}
          if(f==='imagesCount' || f==='wins' || f==='losses' || f==='matchups' || f==='points'){
            return (a[f]-b[f])*dir;
          }
          if(f==='pct'){return (a.pct-b.pct)*dir;}
          return 0;
        });
        return rows.reverse();
      },[items,genStatsSort]);

      const matchupCollectionOptions = useMemo(()=>{
        return collectionStats
          .filter(c=>c.imagesCount>=2)
          .slice()
          .sort((a,b)=>a.name.localeCompare(b.name));
      },[collectionStats]);

      const matchupGeneratorOptions = useMemo(()=>{
        return generatorStats
          .filter(g=>g.imagesCount>=2)
          .slice()
          .sort((a,b)=>a.name.localeCompare(b.name));
      },[generatorStats]);

      // library filtered + sorted list (full, before pagination)
      const libraryItems = useMemo(()=>{
        let list = [...items];
        if(libraryFilter==='unassigned'){
          list = list.filter(it=>!it.collections || it.collections.length===0);
        }
        const searchTerm = librarySearch.trim().toLowerCase();
        if(searchTerm){
          list = list.filter(it => {
            const title = (it.title || '').toLowerCase();
            return title.includes(searchTerm);
          });
        }
        const include = libraryCollectionFilter.include || [];
        const exclude = libraryCollectionFilter.exclude || [];
        const includeGroups = libraryCollectionFilter.includeGroups || [];
        const excludeGroups = libraryCollectionFilter.excludeGroups || [];
        const includeMode = libraryCollectionFilter.mode || 'all';
        const genInclude = libraryGeneratorFilter.include || [];
        const genExclude = libraryGeneratorFilter.exclude || [];
        const genIncludeGroups = libraryGeneratorFilter.includeGroups || [];
        const genExcludeGroups = libraryGeneratorFilter.excludeGroups || [];
        const genIncludeMode = libraryGeneratorFilter.mode || 'all';
        const generatorNameForItem = (it)=>{
          return (it.generator || '').trim() || 'Unspecified';
        };
        const includePredicates = [
          ...include.map(name => (cols)=>cols.includes(name)),
          ...includeGroups.map(id => {
            const members = collectionGroupMembersMap[id] || [];
            return (cols)=>members.some(name=>cols.includes(name));
          })
        ];
        if(includePredicates.length){
          list = list.filter(it=>{
            const cols = it.collections || [];
            if(includeMode==='any'){
              return includePredicates.some(fn=>fn(cols));
            }
            return includePredicates.every(fn=>fn(cols));
          });
        }
        const excludePredicates = [
          ...exclude.map(name => (cols)=>cols.includes(name)),
          ...excludeGroups.map(id => {
            const members = collectionGroupMembersMap[id] || [];
            return (cols)=>members.some(name=>cols.includes(name));
          })
        ];
        if(excludePredicates.length){
          list = list.filter(it=>{
            const cols = it.collections || [];
            return !excludePredicates.some(fn=>fn(cols));
          });
        }
        const genIncludePredicates = [
          ...genInclude.map(name => (gen)=>gen === name),
          ...genIncludeGroups.map(id => {
            const members = generatorGroupMembersMap[id] || [];
            return (gen)=>members.includes(gen);
          })
        ];
        if(genIncludePredicates.length){
          list = list.filter(it=>{
            const gen = generatorNameForItem(it);
            if(genIncludeMode==='any'){
              return genIncludePredicates.some(fn=>fn(gen));
            }
            return genIncludePredicates.every(fn=>fn(gen));
          });
        }
        const genExcludePredicates = [
          ...genExclude.map(name => (gen)=>gen === name),
          ...genExcludeGroups.map(id => {
            const members = generatorGroupMembersMap[id] || [];
            return (gen)=>members.includes(gen);
          })
        ];
        if(genExcludePredicates.length){
          list = list.filter(it=>{
            const gen = generatorNameForItem(it);
            return !genExcludePredicates.some(fn=>fn(gen));
          });
        }
        list.sort((a,b)=>compareBySort(a,b,librarySort));
        return list;
      },[items,librarySort,libraryFilter,libraryCollectionFilter,libraryGeneratorFilter,librarySearch,collectionGroupMembersMap,generatorGroupMembersMap]);

      const activeIncludeFilters = (libraryCollectionFilter.include?.length || 0) + (libraryCollectionFilter.includeGroups?.length || 0);
      const hasCollectionFilters = activeIncludeFilters + (libraryCollectionFilter.exclude?.length || 0) + (libraryCollectionFilter.excludeGroups?.length || 0) > 0;
      const activeGeneratorIncludeFilters = (libraryGeneratorFilter.include?.length || 0) + (libraryGeneratorFilter.includeGroups?.length || 0);
      const hasGeneratorFilters = activeGeneratorIncludeFilters + (libraryGeneratorFilter.exclude?.length || 0) + (libraryGeneratorFilter.excludeGroups?.length || 0) > 0;
      const activeCollectionStatsFilters = (collectionStatsFilter.include?.length || 0) + (collectionStatsFilter.includeGroups?.length || 0);
      const hasCollectionStatsFilters = activeCollectionStatsFilters + (collectionStatsFilter.exclude?.length || 0) + (collectionStatsFilter.excludeGroups?.length || 0) > 0;
      const activeStatsCollectionIncludeFilters = (statsCollectionFilter.include?.length || 0) + (statsCollectionFilter.includeGroups?.length || 0);
      const hasStatsCollectionFilters = activeStatsCollectionIncludeFilters + (statsCollectionFilter.exclude?.length || 0) + (statsCollectionFilter.excludeGroups?.length || 0) > 0;

// stats rows (with win% tie-breaker by wins then matchups)
const statsRows = useMemo(()=>{
  let rows = items.map(it=>({
    ...it,
    matchups: matchupsCount(it),
    pct: pct(it.wins,it.losses),
    points: computePoints(it.wins,it.losses,it.tourneyBonus||0),
    tourneyCount: Number(it.tourneyCount || 0),
    tourneyWins: tourneyWinsFromBonus(it.tourneyBonus || 0)
  }));
  const include = statsCollectionFilter.include || [];
  const exclude = statsCollectionFilter.exclude || [];
  const includeGroups = statsCollectionFilter.includeGroups || [];
  const excludeGroups = statsCollectionFilter.excludeGroups || [];
  const includeMode = statsCollectionFilter.mode || 'all';
  const includePredicates = [
    ...include.map(name => (cols)=>cols.includes(name)),
    ...includeGroups.map(id => {
      const members = collectionGroupMembersMap[id] || [];
      return (cols)=>members.some(name=>cols.includes(name));
    })
  ];
  if(includePredicates.length){
    rows = rows.filter(it=>{
      const cols = it.collections || [];
      if(includeMode==='any'){
        return includePredicates.some(fn=>fn(cols));
      }
      return includePredicates.every(fn=>fn(cols));
    });
  }
  const excludePredicates = [
    ...exclude.map(name => (cols)=>cols.includes(name)),
    ...excludeGroups.map(id => {
      const members = collectionGroupMembersMap[id] || [];
      return (cols)=>members.some(name=>cols.includes(name));
    })
  ];
  if(excludePredicates.length){
    rows = rows.filter(it=>{
      const cols = it.collections || [];
      return !excludePredicates.some(fn=>fn(cols));
    });
  }
  rows.sort((a,b)=>{
    const dir = statsSort.dir==='asc' ? 1 : -1;
    const f = statsSort.field;
    if(f==='title'){
      return a.title.localeCompare(b.title)*dir;
    }else if(f==='matchups'){
      return (a.matchups-b.matchups)*dir;
    }else if(f==='tourneyCount'){
      return (a.tourneyCount-b.tourneyCount)*dir;
    }else if(f==='tourneyWins'){
      return (a.tourneyWins-b.tourneyWins)*dir;
    }else if(f==='wins' || f==='losses' || f==='points'){
      return (a[f]-b[f])*dir;
    }else if(f==='pct'){
      let cmp = a.pct - b.pct;
      if(cmp !== 0) return cmp * dir;
      let winCmp = a.wins - b.wins;
      if(winCmp !== 0) return winCmp * dir;
      let mCmp = a.matchups - b.matchups;
      return mCmp * dir;
    }else if(f==='addedAt'){
      const ta = new Date(a.addedAt||0).getTime();
      const tb = new Date(b.addedAt||0).getTime();
      return (ta-tb)*dir;
    }
    return 0;
  });
  return rows.reverse();
},[items,statsSort,statsCollectionFilter,collectionGroupMembersMap]);


      // pagination: stats
      const statsTotalPages = Math.max(1, Math.ceil(statsRows.length / statsPageSize));
      const statsPageSafe = Math.min(Math.max(statsPage,1), statsTotalPages);
      const statsStart = (statsPageSafe-1) * statsPageSize;
      const statsEnd = statsPageSafe * statsPageSize;
      const statsPageItems = statsRows.slice(statsStart, statsEnd);

      const activeCollectionItems = useMemo(()=>{
        if(!activeCollection) return [];
        if(activeCollectionType==='generator'){
          return items.filter(it=>{
            const gen = (it.generator || '').trim();
            if(activeCollection==='Unspecified'){
              return !gen;
            }
            return gen === activeCollection;
          });
        }
        return items.filter(it=> (it.collections||[]).includes(activeCollection));
      },[items,activeCollection,activeCollectionType]);

      const sortedCollectionItems = useMemo(()=>{
        const arr = [...activeCollectionItems];
        arr.sort((a,b)=>compareBySort(a,b,collectionSort));
        return arr;
      },[activeCollectionItems,collectionSort]);

      // pagination: library
      const libPageSizeNum = libraryPageSize === 'all'
        ? (libraryItems.length || 1)
        : libraryPageSize;
      const libTotalPages = libraryPageSize === 'all'
        ? 1
        : Math.max(1, Math.ceil(libraryItems.length / libPageSizeNum));
      const libPage = Math.min(Math.max(libraryPage,1), libTotalPages);
      const libStart = libraryPageSize === 'all' ? 0 : (libPage-1)*libPageSizeNum;
      const libEnd = libraryPageSize === 'all' ? libraryItems.length : libPage*libPageSizeNum;
      const libraryPageItems = libraryPageSize === 'all'
        ? libraryItems
        : libraryItems.slice(libStart, libEnd);

      // pagination: active collection
      const collPageSizeNum = collectionPageSize === 'all'
        ? (sortedCollectionItems.length || 1)
        : collectionPageSize;
      const collTotalPages = collectionPageSize === 'all'
        ? 1
        : Math.max(1, Math.ceil(sortedCollectionItems.length / collPageSizeNum));
      const collPage = Math.min(Math.max(collectionPage,1), collTotalPages);
      const collStart = collectionPageSize === 'all' ? 0 : (collPage-1)*collPageSizeNum;
      const collEnd = collectionPageSize === 'all' ? sortedCollectionItems.length : collectionPage*collPageSizeNum;
      const collectionPageItems = collectionPageSize === 'all'
        ? sortedCollectionItems
        : sortedCollectionItems.slice(collStart, collEnd);

      const left = items.find(it=>it.id===matchIds[0]) || null;
      const right = items.find(it=>it.id===matchIds[1]) || null;
      const leftSources = useMemo(()=>getMatchupSources(left), [left]);
      const rightSources = useMemo(()=>getMatchupSources(right), [right]);
      const lockedMatchItem = matchMode.type === 'locked'
        ? items.find(it=>it.id===matchMode.lockedId) || null
        : null;
      const previewItem = previewId ? items.find(it=>it.id===previewId) : null;
      const selectionMode = selectedIds.length>0;

      useEffect(()=>{
        async function hydrate(item){
          if(!item) return;
          if(item.fullUrl && isHttpUrl(item.fullUrl)) return;
          if(!window.fetchFullImageUrl) return;
          if(hydratingFullUrls.current.has(item.id)) return;

          hydratingFullUrls.current.add(item.id);
          try{
            const url = await window.fetchFullImageUrl(item.id);
            if(url && url !== item.fullUrl){
              await patchItem(item.id, { fullUrl: url });
            }
          }catch(err){
            console.warn('Full image hydration failed for', item.id, err);
          }finally{
            hydratingFullUrls.current.delete(item.id);
          }
        }

        hydrate(left);
        hydrate(right);
      },[left?.id, right?.id]);

      const allLibPageSelected = libraryPageItems.length>0 && libraryPageItems.every(it=>selectedIds.includes(it.id));
      const allCollPageSelected = collectionPageItems.length>0 && collectionPageItems.every(it=>selectedIds.includes(it.id));
      const allCollSelected = activeCollectionItems.length>0 && activeCollectionItems.every(it=>selectedIds.includes(it.id));

      function toggleSelected(id){
        setSelectedIds(prev=>{
          if(prev.includes(id)){
            return prev.filter(x=>x!==id);
          }else{
            return [...prev,id];
          }
        });
      }
      function clearSelection(){
        setSelectedIds([]);
      }
      function selectAllVisible(list){
        setSelectedIds(list.map(it=>it.id));
      }

      function openPreviewFor(item){
        setPreviewId(item.id);
      }

      function startCropFor(item){
        cropper.startForItem(item);
      }
async function applyCrop(){
  const result = cropper.apply();
  if (!result) return;

  // Build a fresh thumbnail from the cropped pixels (keeps small views sharp)
  let thumb = result.dataUrl;
  try{
    thumb = await dataUrlToThumbDataUrl(result.dataUrl, 480, 0.8);
  }catch(err){
    console.warn('Falling back to cropped full image for thumbnail', err);
  }

  // Instant visual update in state while the upload runs
  setItems(prev => prev.map(it => {
    if (it.id !== result.targetId) return it;
    return {
      ...it,
      dataUrl: result.dataUrl,
      thumbnail: thumb,
      thumbDataUrl: thumb,
      fullUrl: result.dataUrl
    };
  }));

  cropper.setCrop(null);

  // Push the cropped image to Firebase Storage so fullUrl matches the new pixels
  let uploadedUrl = null;
  if (window.uploadDataUrlToFirebase){
    try{
      uploadedUrl = await window.uploadDataUrlToFirebase(result.targetId, result.dataUrl);
    }catch(err){
      console.error('Failed to upload cropped image to Firebase', err);
    }
  }

  const finalFullUrl = uploadedUrl || result.dataUrl;

  // Persist everywhere (IndexedDB + Firestore mirror)
  await patchItem(result.targetId, {
    dataUrl:      result.dataUrl,
    thumbnail:    thumb,
    thumbDataUrl: thumb,
    fullUrl:      finalFullUrl
  });

  if (window.uploadDataUrlToFirebase && !uploadedUrl){
    alert('Saved the cropped image locally, but updating Firebase failed. The app will use the local copy until you retry online.');
  }
}


      function changeStatsSort(field){
        setStatsSort(prev=>{
          if(prev.field===field){
            return {field,dir:prev.dir==='asc'?'desc':'asc'};
          }
          return {field,dir: field==='points' || field==='pct' || field==='matchups' ? 'desc':'asc'};
        });
      }
      function changeGenStatsSort(field){
        setGenStatsSort(prev=>{
          if(prev.field===field){
            return {field,dir:prev.dir==='asc'?'desc':'asc'};
          }
          return {field,dir: field==='points' || field==='pct' || field==='matchups' || field==='imagesCount' ? 'desc':'asc'};
        });
      }
      function changeCollStatsSort(field){
        setCollStatsSort(prev=>{
          if(prev.field===field){
            return {field,dir:prev.dir==='asc'?'desc':'asc'};
          }
          return {field,dir: field==='points' || field==='pct' || field==='matchups' || field==='imagesCount' ? 'desc':'asc'};
        });
      }

      function sortIndicator(active,dir){
        if(!active) return null;
        return <span className="sort-ind">{dir==='asc' ? '‚ñ≤' : '‚ñº'}</span>;
      }

      function startCollectionMatchups(name,type='collection'){
        const next = {type:type,collection:type==='collection'?name:null,generator:type==='generator'?name:null,lockedId:null};
        setMatchMode(next);
        setTab('Matchups');
        const pool = getMatchPool(items,next);
        const [a,b] = pickTwoFromPool(pool);
        setMatchIds([a,b]);
      }

      function startLockedMatchup(item){
        if(!item) return;
        const next = {type:'locked', collection:null, generator:null, lockedId:item.id};
        setMatchMode(next);
        setTab('Matchups');
        const pool = getMatchPool(items,next);
        const [a,b] = pickLockedMatch(pool, item.id);
        setMatchIds([a,b]);
        setPreviewId(null);
      }

function labelForMatchMode(){
  if(matchMode.type==='allFlat') return 'All images (equal chance)';
  if(matchMode.type==='bottom') return 'Bottom 50% by matchups';
  if(matchMode.type==='bottom25') return 'Bottom 25% by matchups';
  if(matchMode.type==='bottom10') return 'Bottom 10% by matchups';
  if(matchMode.type==='topWinPct10') return 'Top 10% by win%';
  if(matchMode.type==='topWinPct25') return 'Top 25% by win%';
  if(matchMode.type==='topWinPct50') return 'Top 50% by win%';
  if(matchMode.type==='bottomWinPct10') return 'Bottom 10% by win%';
  if(matchMode.type==='freshLeaf') return 'Fresh images (leaf icon)';
  if(matchMode.type==='generated') return 'Generated matchup (different generators)';
  if(matchMode.type==='locked' && matchMode.lockedId){
    const lockedItem = items.find(it=>it.id===matchMode.lockedId);
    const name = lockedItem?.title || lockedItem?.id || 'Locked image';
    return `Locked matchup: ${name}`;
  }
  if(matchMode.type==='collection' && matchMode.collection){
    return `Collection: ${matchMode.collection}`;
  }
  if(matchMode.type==='generator' && matchMode.generator){
    return `Generator: ${matchMode.generator}`;
  }
  return 'All images';
}


      const matchSelectValue =
        matchMode.type === 'locked'
          ? 'all'
          :
        matchMode.type === 'collection' && matchMode.collection
          ? `collection:${matchMode.collection}`
          : matchMode.type === 'generator' && matchMode.generator
            ? `generator:${matchMode.generator}`
            : matchMode.type;

      function closeNavMenu(){
        if(navMenuRef.current){
          navMenuRef.current.removeAttribute('open');
        }
      }

      useEffect(()=>{
        try{
          const url = new URL(window.location.href);
          url.searchParams.set('tab', tab);
          window.history.replaceState(null, '', url.toString());
        }catch(e){}
      },[tab]);

      // ----- Render -----
      return (
        <div className="app">

<header className="header">
  <div className="titleBlock">
    <h1>ModelMatchup</h1>

    <div className="badgeSummary">
      <span className="badgeItem">‚≠ê {totalUndefeated}</span>
      <span className="badgeItem">üí© {totalWinless}</span>
      <span className="badgeItem">üñº {items.length}</span>
      <span className="badgeItem">üå± {totalNew}</span>
    </div>
  </div>


<div className="navMenuShell">
  <details ref={navMenuRef} className="navDropdown">
    <summary className="navTrigger">
      <span>Menu</span>
      <span className="pill">{tab}</span>
    </summary>
    <div className="navMenuList">
          {allowedTabs.map(t=>(
            <button
              key={t}
              type="button"
              className={'navItem'+(tab===t?' active':'')}
              onClick={()=>{
                setTab(t);
                if(t!=='Collections'){
                  setActiveCollection(null);
                  setActiveCollectionType('collection');
                  setCollectionTabView('collections');
                }
                closeNavMenu();
              }}
            >
          {t}
          {tab===t && <span className="pill">Active</span>}
        </button>
      ))}
      <div className="navSpacer"></div>
      <a className="navItem" href="tourney.html" onClick={closeNavMenu}>
        Tournament
      </a>
      <a className="navItem" href="settings.html" onClick={closeNavMenu}>
        Settings
      </a>
    </div>
  </details>
</div>


          </header>

          {rankNotice && (
            <div className={`rankNotice ${rankNoticeVisible ? 'show' : ''}`}>
              <div className="rankNoticeList">
                {rankNotice.changes.map(change => (
                  <div className="rankNoticeRow" key={`${change.id}-${change.message}`}>
                    <img
                      className="rankNoticeThumb"
                      src={getDisplaySrc(change.item)}
                      alt={`Image #${change.id}`}
                    />
                    <div className="rankNoticeText">{change.message}</div>
                  </div>
                ))}
              </div>
            </div>
          )}

          {/* LIBRARY */}
          {tab==='Library' && (
            <>
              <section className="pane">
                <div
                  className="dropzone"
                  onClick={()=>{
  if (fileRef.current) {
    fileRef.current.click();
  }
}}

                  onDragOver={e=>e.preventDefault()}
                  onDrop={e=>{
                    e.preventDefault();
                    const dt = e.dataTransfer;
if (dt && dt.files && dt.files.length) {
  handleFiles(dt.files, null);
}

                  }}
                >
                  <p>Drop AI images here or click to upload</p>
                  <input
                    ref={fileRef}
                    type="file"
                    accept="image/*"
                    multiple
                    style={{display:'none'}}
                    onChange={e=>handleFiles(e.target.files,null)}
                  />
                </div>
<div className="toolbar">


  {/* CLEANUP / SYNC */}
  <button className="btn ghost" onClick={()=>{ setCleanupModalOpen(true); setOrphans(null); }}>
    Sync Deletions
  </button>

  {/* EXPORTS */}
  <button className="btn secondary" onClick={exportLibrary}>Export</button>
  <button className="btn ghost" onClick={selectUnexported}>Select unexported</button>
  <button className="btn ghost" onClick={exportMetadata}>Export metadata</button>
<button className="btn ghost" onClick={generateMissingThumbnails}>
  Generate thumbnails
</button>




  {/* METADATA IMPORT (JSON) */}
<button
  className="btn ghost"
  onClick={()=>{
    if (importRef.current) {
      importRef.current.click();
    }
  }}
>
  Import
</button>


  {/* HIDDEN INPUT FOR IMAGE UPLOADS */}
  <input
    ref={imageImportRef}
    type="file"
    accept="image/*"
    multiple
    style={{display:'none'}}
    onChange={e=>{
      const files = e.target.files;
      if (files && files.length){
        handleFiles(files, null);   // <- uses your existing upload logic
      }
      e.target.value = '';
    }}
  />

  {/* HIDDEN INPUT FOR JSON / METADATA IMPORT */}
  <input
    ref={importRef}
    type="file"
    accept="application/json"
    multiple
    style={{display:'none'}}
    onChange={e=>{
      const files = e.target.files;
      if(files && files.length){
        importLibraryFiles(files);  // <- your existing metadata importer
      }
      e.target.value='';
    }}
  />

  <button className="btn ghost" onClick={resetAllStats}>Reset All Stats</button>
  <button className="btn danger" onClick={clearLibrary}>Delete Library</button>
</div>

                <div className="toolbar" style={{marginTop:10,justifyContent:'space-between'}}>
                  <div className="flexRow">
                    <label className="smallMuted">
                      Sort by{' '}
                      <select
                        className="select"
                        value={librarySort.field}
                        onChange={e => setLibrarySort(s => ({ ...s, field: e.target.value }))}
                      >
                        <option value="addedAt">Date added</option>
                        <option value="title">Title</option>
                        <option value="points">Points</option>
                        <option value="matchups"># Matchups</option>
                      </select>
                    </label>
                    <label className="smallMuted">
                      Direction{' '}
                      <select
                        className="select"
                        value={librarySort.dir}
                        onChange={e => setLibrarySort(s => ({ ...s, dir: e.target.value }))}
                      >
                        <option value="desc">Desc</option>
                        <option value="asc">Asc</option>
                      </select>
                    </label>
                    <label className="smallMuted">
                      Filter{' '}
                      <select
                        className="select"
                        value={libraryFilter}
                        onChange={e=>setLibraryFilter(e.target.value)}
                      >
                        <option value="all">All images</option>
                        <option value="unassigned">No collections</option>
                      </select>
                    </label>
                    <label className="smallMuted" style={{display:'flex',flexDirection:'column',gap:4}}>
                      Search
                      <input
                        className="input"
                        type="text"
                        placeholder="Search titles..."
                        value={librarySearch}
                        onChange={e=>{ setLibrarySearch(e.target.value); setLibraryPage(1); }}
                        style={{minWidth:180}}
                      />
                    </label>
                  </div>
                  <div className="flexRow">
                    <span className="smallMuted">View</span>
                    <button
                      className={'btn sm '+(libraryViewMode==='cards'?'secondary':'ghost')}
                      onClick={()=>setLibraryViewMode('cards')}
                    >
                      Cards
                    </button>
                    <button
                      className={'btn sm '+(libraryViewMode==='gallery'?'secondary':'ghost')}
                      onClick={()=>setLibraryViewMode('gallery')}
                    >
                      Gallery
                    </button>
                  </div>
                </div>

                {allCollectionNames.length > 0 && (
                  <div className="toolbar collectionFilterToolbar" style={{marginTop:8}}>
                    <div className="collectionFilterHeader">
                      <span className="smallMuted">
                        Collection/group filter (click names to include ‚Üí exclude ‚Üí clear; use the arrow to open a group):
                      </span>
                      <div className="flexRow" style={{gap:6, flexWrap:'wrap'}}>
                        <button className="btn sm ghost" onClick={createCollectionGroup}>
                          Create group
                        </button>
                        {hasCollectionFilters && (
                          <button
                            className="btn sm ghost"
                            onClick={()=>setLibraryCollectionFilter({include:[],exclude:[],includeGroups:[],excludeGroups:[],mode:'all'})}
                          >
                            Clear filters
                          </button>
                        )}
                      </div>
                    </div>
                    {activeIncludeFilters > 1 && (
                      <div className="flexRow" style={{gap:6, alignItems:'center', flexWrap:'wrap'}}>
                        <span className="smallMuted">Include logic:</span>
                        <button
                          className={'btn sm '+((libraryCollectionFilter.mode||'all')==='all' ? 'secondary' : 'ghost')}
                          onClick={()=>setLibraryCollectionFilter(prev=>({...prev,mode:'all'}))}
                        >
                          Match all selected
                        </button>
                        <button
                          className={'btn sm '+((libraryCollectionFilter.mode||'all')==='any' ? 'secondary' : 'ghost')}
                          onClick={()=>setLibraryCollectionFilter(prev=>({...prev,mode:'any'}))}
                        >
                          Match any selected
                        </button>
                      </div>
                    )}
                    <div className="collectionGroupsGrid">
                      {collectionGroups.map(group=>{
                        const visibleMembers = (group.members || []).filter(name=>allCollectionNames.includes(name));
                        const isIncludeGroup = (libraryCollectionFilter.includeGroups || []).includes(group.id);
                        const isExcludeGroup = (libraryCollectionFilter.excludeGroups || []).includes(group.id);
                        let groupClass = 'ghost';
                        if(isIncludeGroup) groupClass = 'secondary';
                        if(isExcludeGroup) groupClass = 'danger';
                        return (
                          <div className="collectionGroupCard" key={group.id}>
                            <div className="collectionGroupHeader">
                              <button
                                className={'btn sm '+groupClass+' collectionGroupToggle'}
                                onClick={()=>cycleCollectionGroupFilter(group.id)}
                              >
                                <span>{group.name}</span>
                                <span className="smallMuted">({visibleMembers.length})</span>
                              </button>
                              <button
                                className="btn sm ghost collectionGroupCaret"
                                aria-label={group.open ? 'Collapse group' : 'Expand group'}
                                title={group.open ? 'Collapse group' : 'Expand group'}
                                onClick={()=>toggleGroupOpen(group.id)}
                              >
                                <span aria-hidden="true">{group.open ? '‚ñæ' : '‚ñ∏'}</span>
                              </button>
                            </div>
                            {group.open && (
                              <div className="collectionGroupItems">
                                {visibleMembers.length>0 ? (
                                  visibleMembers.map(renderCollectionRow)
                                ) : (
                                  <span className="smallMuted">No collections in this group yet.</span>
                                )}
                              </div>
                            )}
                          </div>
                        );
                      })}
                      {ungroupedCollections.length>0 && (
                        <div className="collectionGroupCard">
                          <div className="collectionGroupHeader">
                            <span className="smallMuted">Ungrouped</span>
                            <span className="smallMuted">{ungroupedCollections.length} collections</span>
                          </div>
                          <div className="collectionGroupItems">
                            {ungroupedCollections.map(renderCollectionRow)}
                          </div>
                        </div>
                      )}
                    </div>
                  </div>
                )}
                {allGeneratorNames.length > 0 && (
                  <div className="toolbar collectionFilterToolbar" style={{marginTop:8}}>
                    <div className="collectionFilterHeader">
                      <span className="smallMuted">
                        Generator/group filter (click names to include ‚Üí exclude ‚Üí clear; use the arrow to open a group):
                      </span>
                      <div className="flexRow" style={{gap:6, flexWrap:'wrap'}}>
                        <button className="btn sm ghost" onClick={createGeneratorGroup}>
                          Create group
                        </button>
                        {hasGeneratorFilters && (
                          <button
                            className="btn sm ghost"
                            onClick={()=>setLibraryGeneratorFilter({include:[],exclude:[],includeGroups:[],excludeGroups:[],mode:'all'})}
                          >
                            Clear filters
                          </button>
                        )}
                      </div>
                    </div>
                    {activeGeneratorIncludeFilters > 1 && (
                      <div className="flexRow" style={{gap:6, alignItems:'center', flexWrap:'wrap'}}>
                        <span className="smallMuted">Include logic:</span>
                        <button
                          className={'btn sm '+((libraryGeneratorFilter.mode||'all')==='all' ? 'secondary' : 'ghost')}
                          onClick={()=>setLibraryGeneratorFilter(prev=>({...prev,mode:'all'}))}
                        >
                          Match all selected
                        </button>
                        <button
                          className={'btn sm '+((libraryGeneratorFilter.mode||'all')==='any' ? 'secondary' : 'ghost')}
                          onClick={()=>setLibraryGeneratorFilter(prev=>({...prev,mode:'any'}))}
                        >
                          Match any selected
                        </button>
                      </div>
                    )}
                    <div className="collectionGroupsGrid">
                      {generatorGroups.map(group=>{
                        const visibleMembers = (group.members || []).filter(name=>allGeneratorNames.includes(name));
                        const isIncludeGroup = (libraryGeneratorFilter.includeGroups || []).includes(group.id);
                        const isExcludeGroup = (libraryGeneratorFilter.excludeGroups || []).includes(group.id);
                        let groupClass = 'ghost';
                        if(isIncludeGroup) groupClass = 'secondary';
                        if(isExcludeGroup) groupClass = 'danger';
                        return (
                          <div className="collectionGroupCard" key={group.id}>
                            <div className="collectionGroupHeader">
                              <button
                                className={'btn sm '+groupClass+' collectionGroupToggle'}
                                onClick={()=>cycleGeneratorGroupFilter(group.id)}
                              >
                                <span>{group.name}</span>
                                <span className="smallMuted">({visibleMembers.length})</span>
                              </button>
                              <button
                                className="btn sm ghost collectionGroupCaret"
                                aria-label={group.open ? 'Collapse group' : 'Expand group'}
                                title={group.open ? 'Collapse group' : 'Expand group'}
                                onClick={()=>toggleGeneratorGroupOpen(group.id)}
                              >
                                <span aria-hidden="true">{group.open ? '‚ñæ' : '‚ñ∏'}</span>
                              </button>
                            </div>
                            {group.open && (
                              <div className="collectionGroupItems generatorList">
                                {visibleMembers.length>0 ? (
                                  visibleMembers.map(renderGeneratorRow)
                                ) : (
                                  <span className="smallMuted">No generators in this group yet.</span>
                                )}
                              </div>
                            )}
                          </div>
                        );
                      })}
                      {ungroupedGenerators.length>0 && (
                        <div className="collectionGroupCard">
                          <div className="collectionGroupHeader">
                            <span className="smallMuted">Ungrouped</span>
                            <span className="smallMuted">{ungroupedGenerators.length} generators</span>
                          </div>
                          <div className="collectionGroupItems generatorList">
                            {ungroupedGenerators.map(renderGeneratorRow)}
                          </div>
                        </div>
                      )}
                    </div>
                  </div>
                )}

                {items.length>0 && (
                  <div className="pager">
                    <div>Page {libPage} of {libTotalPages}</div>
                    <div className="flexRow">
                      <label className="smallMuted">
                        Per page{' '}
                        <select
                          className="select"
                          value={String(libraryPageSize)}
                          onChange={e=>{
                            const v = e.target.value === 'all' ? 'all' : Number(e.target.value);
                            setLibraryPageSize(v);
                            setLibraryPage(1);
                          }}
                        >
                          <option value="25">25</option>
                          <option value="50">50</option>
                          <option value="100">100</option>
                          <option value="250">250</option>
                          <option value="500">500</option>
                          <option value="all">All</option>
                        </select>
                      </label>
                      <button
                        className="btn sm ghost"
                        onClick={()=>setLibraryPage(p=>Math.max(1,p-1))}
                        disabled={libPage<=1}
                      >
                        Prev
                      </button>
                      <button
                        className="btn sm ghost"
                        onClick={()=>setLibraryPage(p=>Math.min(libTotalPages,p+1))}
                        disabled={libPage>=libTotalPages}
                      >
                        Next
                      </button>
                    </div>
                  </div>
                )}
              </section>

              {items.length===0 && (
                <p className="hint">No images yet. Import or upload to get started.</p>
              )}

              {items.length>0 && libraryViewMode==='cards' && (
                <ul className="grid">
                  {libraryPageItems.map(it=>(
                    <li key={it.id} className="card">
<div className="cardThumb" onClick={()=>openPreviewFor(it)}>
  <img
  src={it.thumbnail || it.fullUrl || it.dataUrl}
  alt={it.title || 'Image'}
/>

  {renderBadges(it.id,'badgeRow-top-right')}
</div>

                      <div className="cardBody">
                        <div className="fieldRow">
                          <label>Title</label>
                          <input
                            value={it.title}
                            onChange={e=>patchItem(it.id,{title:e.target.value})}
                          />
                        </div>
                        <div className="fieldRow">
                          <label>Collections (comma-separated)</label>
                          <input
                            value={libraryCollectionEdits[it.id] ?? collectionsToString(it.collections)}
                            onChange={e=>{
                              const nextValue = e.target.value;
                              setLibraryCollectionEdits(prev=>({...prev,[it.id]:nextValue}));
                            }}
                            onBlur={()=>commitLibraryCollections(it.id)}
                            onKeyDown={e=>{
                              if(e.key==='Enter'){
                                commitLibraryCollections(it.id);
                                e.currentTarget.blur();
                              }
                            }}
                          />
                        </div>
                        <div className="fieldRow">
                          <label>AI Generator</label>
                          <select
                            className="select"
                            value={it.generator || ''}
                            onChange={e=>patchItem(it.id,{generator:e.target.value})}
                          >
                            {generatorSelectOptions.map(opt=>(
                              <option key={opt.label} value={opt.value}>{opt.label}</option>
                            ))}
                          </select>
                        </div>
<div className="statLine">
  <span>W {it.wins||0}</span>
  <span>L {it.losses||0}</span>
  <span>Win % {(pct(it.wins,it.losses)*100).toFixed(0)}%</span>
  <span>Pts {computePoints(it.wins,it.losses,it.tourneyBonus||0)}</span>
  <span>M {matchupsCount(it)}</span>
  <span>T {it.tourneyCount || 0}</span> {/* NEW */}
</div>

                        <div className="addedAt" style={{whiteSpace:'pre-line'}}>
  Added {formatAddedAt(it.addedAt)}
</div>

                        <div className="toolbar" style={{marginTop:4}}>
                          <button className="btn ghost sm" onClick={()=>startCropFor(it)}>Crop</button>
                          <button className="btn danger sm" onClick={()=>removeItem(it.id)}>Delete</button>
                        </div>
                      </div>
                    </li>
                  ))}
                </ul>
              )}

              {items.length>0 && libraryViewMode==='gallery' && (
                <section className="pane" style={{padding:10}}>
                  <div className="galleryControls">
                    <div className="flexRow">
                      <button
                        className="btn sm secondary"
                        onClick={()=>{
                          if(allLibPageSelected) clearSelection();
                          else selectAllVisible(libraryPageItems);
                        }}
                      >
                        {allLibPageSelected ? 'Clear all on page' : 'Select all on page'}
                      </button>
                      {selectedIds.length>0 && (
                        <button
                          className="btn sm ghost"
                          onClick={()=>{
                            setBatchReplaceFrom('');
                            setBatchReplaceTo('');
                            setBatchGenerator('__keep__');
                            setBatchOpen(true);
                          }}
                        >
                          Batch edit ({selectedIds.length})
                        </button>
                      )}
                    </div>
                    <div className="flexRow" style={{gap:10, alignItems:'center'}}>
                      <label className="smallMuted">
                        Columns{' '}
                        <select
                          className="select"
                          value={String(libraryGalleryColumns)}
                          onChange={e=>setLibraryGalleryColumns(Number(e.target.value))}
                        >
                          {galleryColumnOptions.map(opt=>(
                            <option key={opt} value={opt}>{opt} columns</option>
                          ))}
                        </select>
                      </label>
                      <span className="smallMuted">
                        {selectionMode
                          ? 'Selection mode: click images to toggle selection'
                          : 'Click an image to view & edit. Export will use any selected images.'}
                      </span>
                    </div>
                  </div>
                  <div
                    className="galleryGrid"
                    style={{gridTemplateColumns:`repeat(${libraryGalleryColumns}, minmax(0,1fr))`}}
                  >
                    {libraryPageItems.map(it=>{
                      const isSel = selectedIds.includes(it.id);
                      return (
                        <div
                          key={it.id}
                          className="galleryItem"
                          onClick={()=>{
                            if(selectionMode){
                              toggleSelected(it.id);
                            }else{
                              openPreviewFor(it);
                            }
                          }}
                        >
<SafeImage
  item={it}
  className="galleryImg"
  src={getDisplaySrc(it)}
  fallbackSrcs={getDisplaySources(it)}
  alt={it.title || 'Image'}
  onResolved={(url)=>patchItem(it.id,{fullUrl:url})}
/>

                          <div className="galleryOverlay" />
                          {renderBadges(it.id,'badgeRow-top-right')}
                          <div className="galleryMeta">
                            <div
                              className="galleryCheckWrap"
                              onClick={e=>{e.stopPropagation();toggleSelected(it.id);}}
                            >
                              <span className={'checkbox'+(isSel?' checked':'')}></span>
                            </div>
                          </div>
                        </div>
                      );
                    })}
                  </div>
                  {items.length>0 && (
                    <div className="pager">
                      <div>Page {libPage} of {libTotalPages}</div>
                      <div className="flexRow">
                        <label className="smallMuted">
                          Per page{' '}
                          <select
                            className="select"
                            value={String(libraryPageSize)}
                            onChange={e=>{
                              const v = e.target.value === 'all' ? 'all' : Number(e.target.value);
                              setLibraryPageSize(v);
                              setLibraryPage(1);
                            }}
                          >
                            <option value="25">25</option>
                            <option value="50">50</option>
                            <option value="100">100</option>
                            <option value="250">250</option>
                            <option value="500">500</option>
                            <option value="all">All</option>
                          </select>
                        </label>
                        <button
                          className="btn sm ghost"
                          onClick={()=>setLibraryPage(p=>Math.max(1,p-1))}
                          disabled={libPage<=1}
                        >
                          Prev
                        </button>
                        <button
                          className="btn sm ghost"
                          onClick={()=>setLibraryPage(p=>Math.min(libTotalPages,p+1))}
                          disabled={libPage>=libTotalPages}
                        >
                          Next
                        </button>
                      </div>
                    </div>
                  )}
                </section>
              )}
            </>
          )}

          {/* MATCHUPS */}
          {tab==='Matchups' && (
            <section className="pane">
              <div className="toolbar" style={{justifyContent:'space-between',marginBottom:6}}>
                <div className="flexRow">
                  <label className="smallMuted">
                    Matchup pool{' '}
<select
  className="select"
  value={matchSelectValue}
  onChange={e=>{
    const v = e.target.value;
    const simpleModes = [
      'all',
      'allFlat',
      'generated',
      'bottom',
      'bottom25',
      'bottom10',
      'topWinPct10',
      'topWinPct25',
      'topWinPct50',
      'bottomWinPct10',
      'freshLeaf'
    ];

    if(simpleModes.includes(v)){
      const next = {type:v, collection:null, generator:null, lockedId:null};
      setMatchMode(next);
      const pool = getMatchPool(items,next);
      const [a,b] = (v === 'allFlat')
        ? pickTwoFromPoolFlat(pool)
        : v === 'generated'
          ? pickTwoFromPoolDifferentGenerators(pool)
          : pickTwoFromPool(pool);
      setMatchIds([a,b]);
    }else if(v.startsWith('collection:')){
      const name = v.slice('collection:'.length);
      const next = {type:'collection',collection:name,generator:null,lockedId:null};
      setMatchMode(next);
      const pool = getMatchPool(items,next);
      const [a,b] = pickTwoFromPool(pool);
      setMatchIds([a,b]);
    }else if(v.startsWith('generator:')){
      const name = v.slice('generator:'.length);
      const next = {type:'generator',generator:name,collection:null,lockedId:null};
      setMatchMode(next);
      const pool = getMatchPool(items,next);
      const [a,b] = pickTwoFromPool(pool);
      setMatchIds([a,b]);
    }
  }}
>


<option value="all">All images</option>
<option value="allFlat">All images (equal chance)</option>
<option value="generated">Generated matchups (different generators)</option>

<option value="bottom">Bottom 50% by matchups</option>
<option value="bottom25">Bottom 25% by matchups</option>
<option value="bottom10">Bottom 10% by matchups</option>

<option value="topWinPct10">Top 10% by win%</option>
<option value="topWinPct25">Top 25% by win%</option>
<option value="topWinPct50">Top 50% by win%</option>
<option value="bottomWinPct10">Bottom 10% by win%</option>

<option value="freshLeaf">Fresh images (leaf icon)</option>

{matchupCollectionOptions
  .map(c=>(
    <option key={c.name} value={`collection:${c.name}`}>
      Collection: {c.name}
    </option>
  ))}

{matchupGeneratorOptions
  .map(g=>(
    <option key={`gen-${g.name}`} value={`generator:${g.name}`}>
      Generator: {g.name}
    </option>
  ))}


</select>
                  </label>
                  {matchMode.type==='collection' && matchMode.collection && (
                    <span className="pill">Current: {matchMode.collection}</span>
                  )}
                  {matchMode.type==='generator' && matchMode.generator && (
                    <span className="pill">Current: {matchMode.generator}</span>
                  )}
                  {matchMode.type==='locked' && lockedMatchItem && (
                    <span className="pill">Locked: {lockedMatchItem.title || 'Untitled'}</span>
                  )}
                </div>
                <div className="flexRow">
                  <button className="btn sm" onClick={()=>rerollMatch()}>
                    Next
                  </button>
                  <button className="btn sm ghost" onClick={undoLast} disabled={!lastMatch}>
                    Undo last result
                  </button>
                </div>
              </div>

              {(!left || !right) ? (
                <p className="hint">
                  {matchMode.type==='generated'
                    ? 'You need at least two generators with images in the current pool to run generated matchups.'
                    : 'You need at least two images in the current pool to run matchups.'}
                </p>
              ) : (
                <>
<div className="arena">
  <button className={`imageCard ${matchupMedalClass(left.id)}`} onClick={()=>recordWin(left.id)}>
    <SafeImage
      item={left}
      src={leftSources[0]}
      fallbackSrcs={leftSources}
      alt="left"
      preferRemote={true}
      eagerHydrate={true}
      onResolved={(url)=>patchItem(left.id,{fullUrl:url})}
    />
    {renderBadges(left.id,'badgeRow-top-right')}
  </button>
  <div className="vs">VS</div>
  <button className={`imageCard ${matchupMedalClass(right.id)}`} onClick={()=>recordWin(right.id)}>
    <SafeImage
      item={right}
      src={rightSources[0]}
      fallbackSrcs={rightSources}
      alt="right"
      preferRemote={true}
      eagerHydrate={true}
      onResolved={(url)=>patchItem(right.id,{fullUrl:url})}
    />
    {renderBadges(right.id,'badgeRow-top-right')}
  </button>
</div>

                  <div className="matchMetaRow">
                    <div className="matchMetaBox">
                      <div className="matchMetaTitle">Left image</div>
                      <div className="matchMetaStats">
                        {left.title || 'Untitled'}<br/>
                        <span className="matchRecord">
                          W {left.wins} ‚Ä¢ L {left.losses} ‚Ä¢ Pts {computePoints(left.wins,left.losses,left.tourneyBonus||0)} ‚Ä¢ M {matchupsCount(left)}
                        </span><br/>
                        Collections: {collectionsToString(left.collections)}
                      </div>
                      <div className="toolbar" style={{marginTop:4,gap:6}}>
                        <button className="btn ghost sm" onClick={()=>openPreviewFor(left)}>View</button>
                        <button className="btn ghost sm" onClick={()=>startCropFor(left)}>Crop</button>
                        <button className="btn ghost sm" onClick={()=>startLockedMatchup(left)}>Lock matchup</button>
                      </div>
                    </div>
                    <div></div>
                    <div className="matchMetaBox">
                      <div className="matchMetaTitle">Right image</div>
                      <div className="matchMetaStats">
                        {right.title || 'Untitled'}<br/>
                        <span className="matchRecord">
                          W {right.wins} ‚Ä¢ L {right.losses} ‚Ä¢ Pts {computePoints(right.wins,right.losses,right.tourneyBonus||0)} ‚Ä¢ M {matchupsCount(right)}
                        </span><br/>
                        Collections: {collectionsToString(right.collections)}
                      </div>
                      <div className="toolbar" style={{marginTop:4,gap:6}}>
                        <button className="btn ghost sm" onClick={()=>openPreviewFor(right)}>View</button>
                        <button className="btn ghost sm" onClick={()=>startCropFor(right)}>Crop</button>
                        <button className="btn ghost sm" onClick={()=>startLockedMatchup(right)}>Lock matchup</button>
                      </div>
                    </div>
                  </div>
                  <div className="matchFooter">
                    <button className="btn sm" onClick={()=>rerollMatch()}>
                      Next matchup
                    </button>
                    <button className="btn sm ghost" onClick={undoLast} disabled={!lastMatch}>
                      Undo last
                    </button>
                  </div>
                  <div className="matchPoolInfo">
                    Pool: {labelForMatchMode()}
                  </div>
                </>
              )}
            </section>
          )}

          {/* STATS */}
          {tab==='Stats' && (
            <section className="statsTab">
              {items.length===0 ? (
                <p className="hint">No images yet.</p>
              ) : (
                <>
                <div className="tabs" style={{marginBottom:10}}>
                  <button
                    className={`tab ${statsView==='images'?'active':''}`}
                    onClick={()=>setStatsView('images')}
                  >
                    Image stats
                  </button>
                  <button
                    className={`tab ${statsView==='generators'?'active':''}`}
                    onClick={()=>setStatsView('generators')}
                  >
                    Generator stats
                  </button>
                </div>
                {statsView==='images' ? (
                  <>
                    {allCollectionNames.length > 0 && (
                      <div className="toolbar collectionFilterToolbar" style={{marginTop:8}}>
                        <div className="collectionFilterHeader">
                          <span className="smallMuted">
                            Collection/group filter (click names to include ‚Üí exclude ‚Üí clear; use the arrow to open a group):
                          </span>
                          <div className="flexRow" style={{gap:6, flexWrap:'wrap'}}>
                            <button className="btn sm ghost" onClick={createCollectionGroup}>
                              Create group
                            </button>
                            {hasStatsCollectionFilters && (
                              <button
                                className="btn sm ghost"
                                onClick={()=>setStatsCollectionFilter({include:[],exclude:[],includeGroups:[],excludeGroups:[],mode:'all'})}
                              >
                                Clear filters
                              </button>
                            )}
                          </div>
                        </div>
                        {activeStatsCollectionIncludeFilters > 1 && (
                          <div className="flexRow" style={{gap:6, alignItems:'center', flexWrap:'wrap'}}>
                            <span className="smallMuted">Include logic:</span>
                            <button
                              className={'btn sm '+((statsCollectionFilter.mode||'all')==='all' ? 'secondary' : 'ghost')}
                              onClick={()=>setStatsCollectionFilter(prev=>({...prev,mode:'all'}))}
                            >
                              Match all selected
                            </button>
                            <button
                              className={'btn sm '+((statsCollectionFilter.mode||'all')==='any' ? 'secondary' : 'ghost')}
                              onClick={()=>setStatsCollectionFilter(prev=>({...prev,mode:'any'}))}
                            >
                              Match any selected
                            </button>
                          </div>
                        )}
                        <div className="collectionGroupsGrid">
                          {collectionGroups.map(group=>{
                            const visibleMembers = (group.members || []).filter(name=>allCollectionNames.includes(name));
                            const isIncludeGroup = (statsCollectionFilter.includeGroups || []).includes(group.id);
                            const isExcludeGroup = (statsCollectionFilter.excludeGroups || []).includes(group.id);
                            let groupClass = 'ghost';
                            if(isIncludeGroup) groupClass = 'secondary';
                            if(isExcludeGroup) groupClass = 'danger';
                            return (
                              <div className="collectionGroupCard" key={group.id}>
                                <div className="collectionGroupHeader">
                                  <button
                                    className={'btn sm '+groupClass+' collectionGroupToggle'}
                                    onClick={()=>cycleStatsCollectionGroupFilter(group.id)}
                                  >
                                    <span>{group.name}</span>
                                    <span className="smallMuted">({visibleMembers.length})</span>
                                  </button>
                                  <button
                                    className="btn sm ghost collectionGroupCaret"
                                    aria-label={group.open ? 'Collapse group' : 'Expand group'}
                                    title={group.open ? 'Collapse group' : 'Expand group'}
                                    onClick={()=>toggleGroupOpen(group.id)}
                                  >
                                    <span aria-hidden="true">{group.open ? '‚ñæ' : '‚ñ∏'}</span>
                                  </button>
                                </div>
                                {group.open && (
                                  <div className="collectionGroupItems">
                                    {visibleMembers.length>0 ? (
                                      visibleMembers.map(renderStatsCollectionRow)
                                    ) : (
                                      <span className="smallMuted">No collections in this group yet.</span>
                                    )}
                                  </div>
                                )}
                              </div>
                            );
                          })}
                          {ungroupedCollections.length>0 && (
                            <div className="collectionGroupCard">
                              <div className="collectionGroupHeader">
                                <span className="smallMuted">Ungrouped</span>
                                <span className="smallMuted">{ungroupedCollections.length} collections</span>
                              </div>
                              <div className="collectionGroupItems">
                                {ungroupedCollections.map(renderStatsCollectionRow)}
                              </div>
                            </div>
                          )}
                        </div>
                      </div>
                    )}
                <table>
<thead>
  <tr>
    <th>#</th>
    <th>Image #</th>
    <th>Image</th>
    <th className="sortable" onClick={()=>changeStatsSort('title')}>
      Title{sortIndicator(statsSort.field==='title',statsSort.dir)}
    </th>
    <th>Collections</th>
    <th className="sortable" onClick={()=>changeStatsSort('addedAt')}>
      Added{sortIndicator(statsSort.field==='addedAt',statsSort.dir)}
    </th>
    <th className="sortable" onClick={()=>changeStatsSort('wins')}>
      W{sortIndicator(statsSort.field==='wins',statsSort.dir)}
    </th>
    <th className="sortable" onClick={()=>changeStatsSort('losses')}>
      L{sortIndicator(statsSort.field==='losses',statsSort.dir)}
    </th>
    <th className="sortable" onClick={()=>changeStatsSort('matchups')}>
      M{sortIndicator(statsSort.field==='matchups',statsSort.dir)}
    </th>
    <th className="sortable" onClick={()=>changeStatsSort('tourneyCount')}>
      T{sortIndicator(statsSort.field==='tourneyCount',statsSort.dir)}
    </th>
    <th className="sortable" onClick={()=>changeStatsSort('tourneyWins')}>
      TW{sortIndicator(statsSort.field==='tourneyWins',statsSort.dir)}
    </th>
    <th className="sortable" onClick={()=>changeStatsSort('pct')}>
      Win%{sortIndicator(statsSort.field==='pct',statsSort.dir)}
    </th>
    <th className="sortable" onClick={()=>changeStatsSort('points')}>
      Points{sortIndicator(statsSort.field==='points',statsSort.dir)}
    </th>
  </tr>
</thead>

<tbody>
  {statsPageItems.map((x,i)=>(
    <tr key={x.id}>
      <td>{statsStart + i + 1}</td>
      <td>{x.id}</td>
<td>
  <div style={{display:'flex',alignItems:'center',gap:4}}>
    <div className="thumbWrap">
      <SafeImage
        item={x}
        className="thumb"
        src={getDisplaySrc(x)}
        fallbackSrcs={getDisplaySources(x)}
        alt={x.title || 'Image'}
        onClick={() => openPreviewFor(x)}
        onResolved={(url)=>patchItem(x.id,{fullUrl:url})}
      />
    </div>
    {renderBadges(x.id, 'badgeRow-inline')}
  </div>
</td>
      <td>{x.title}</td>
      <td>{collectionsToString(x.collections)}</td>
<td style={{whiteSpace:'pre-line'}}>{formatAddedAt(x.addedAt)}</td>
      <td>{x.wins}</td>
      <td>{x.losses}</td>
      <td>{x.matchups}</td>
      <td>{x.tourneyCount || 0}</td>
      <td>{x.tourneyWins || 0}</td>
      <td>{x.pct.toFixed(3)}</td>
      <td>{x.points}</td>
    </tr>
  ))}
</tbody>

                </table>
                {statsTotalPages>1 && (
                  <div className="pager">
                    <div>Page {statsPageSafe} of {statsTotalPages}</div>
                    <div className="flexRow">
                      <button
                        className="btn sm ghost"
                        onClick={()=>setStatsPage(p=>Math.max(1,p-1))}
                        disabled={statsPageSafe<=1}
                      >
                        Prev
                      </button>
                      <button
                        className="btn sm ghost"
                        onClick={()=>setStatsPage(p=>Math.min(statsTotalPages,p+1))}
                        disabled={statsPageSafe>=statsTotalPages}
                      >
                        Next
                      </button>
                    </div>
                  </div>
                )}
                  </>
                ) : (
                  <>
                  {generatorStats.length===0 ? (
                    <p className="hint">No generators yet. Add generator names to your images to see their performance.</p>
                  ) : (
                    <table>
                      <thead>
                        <tr>
                          <th>#</th>
                          <th>Preview</th>
                          <th className="sortable" onClick={()=>changeGenStatsSort('name')}>
                            Generator{sortIndicator(genStatsSort.field==='name',genStatsSort.dir)}
                          </th>
                          <th className="sortable" onClick={()=>changeGenStatsSort('imagesCount')}>
                            # Images{sortIndicator(genStatsSort.field==='imagesCount',genStatsSort.dir)}
                          </th>
                          <th className="sortable" onClick={()=>changeGenStatsSort('wins')}>
                            W{sortIndicator(genStatsSort.field==='wins',genStatsSort.dir)}
                          </th>
                          <th className="sortable" onClick={()=>changeGenStatsSort('losses')}>
                            L{sortIndicator(genStatsSort.field==='losses',genStatsSort.dir)}
                          </th>
                          <th className="sortable" onClick={()=>changeGenStatsSort('matchups')}>
                            M{sortIndicator(genStatsSort.field==='matchups',genStatsSort.dir)}
                          </th>
                          <th className="sortable" onClick={()=>changeGenStatsSort('pct')}>
                            Win%{sortIndicator(genStatsSort.field==='pct',genStatsSort.dir)}
                          </th>
                          <th className="sortable" onClick={()=>changeGenStatsSort('points')}>
                            Points{sortIndicator(genStatsSort.field==='points',genStatsSort.dir)}
                          </th>
                        </tr>
                      </thead>
                      <tbody>
                        {generatorStats.map((g,i)=>(
                          <tr key={g.name}>
                            <td>{i+1}</td>
                            <td>
                              {g.bestItem ? (
                                <div className="thumbWrap">
                                  <SafeImage
                                    item={g.bestItem}
                                    className="thumb"
                                    src={getDisplaySrc(g.bestItem)}
                                    fallbackSrcs={getDisplaySources(g.bestItem)}
                                    alt={g.bestItem.title || 'Image'}
                                    onClick={() => openPreviewFor(g.bestItem)}
                                    onResolved={(url)=>patchItem(g.bestItem.id,{fullUrl:url})}
                                  />
                                </div>
                              ) : (
                                <span className="smallMuted">‚Äî</span>
                              )}
                            </td>
                            <td>{g.name}</td>
                            <td>{g.imagesCount}</td>
                            <td>{g.wins}</td>
                            <td>{g.losses}</td>
                            <td>{g.matchups}</td>
                            <td>{g.pct.toFixed(3)}</td>
                            <td>{g.points}</td>
                          </tr>
                        ))}
                      </tbody>
                    </table>
                  )}
                  </>
                )}
                </>
              )}
            </section>
          )}
{/* COLLECTIONS LIST / DETAIL */}
          {tab==='Collections' && !activeCollection && (
            <section className="statsTab">
              <div className="tabs" style={{marginBottom:10}}>
                <button
                  className={`tab ${collectionTabView==='collections'?'active':''}`}
                  onClick={()=>{
                    setCollectionTabView('collections');
                    setActiveCollection(null);
                    setActiveCollectionType('collection');
                  }}
                >
                  Collections
                </button>
                <button
                  className={`tab ${collectionTabView==='generators'?'active':''}`}
                  onClick={()=>{
                    setCollectionTabView('generators');
                    setActiveCollection(null);
                    setActiveCollectionType('generator');
                  }}
                >
                  Generators
                </button>
              </div>
              {collectionTabView==='collections' ? (
                <>
                  {collectionStats.length===0 ? (
                    <p className="hint">No collections yet. Add collection names to images in the Library.</p>
                  ) : (
                    <>
                      {allCollectionNames.length > 0 && (
                        <div className="toolbar collectionFilterToolbar" style={{marginTop:8}}>
                          <div className="collectionFilterHeader">
                            <span className="smallMuted">
                              Collection/group filter (click names to include ‚Üí exclude ‚Üí clear; use the arrow to open a group):
                            </span>
                            <div className="flexRow" style={{gap:6, flexWrap:'wrap'}}>
                              {hasCollectionStatsFilters && (
                                <button
                                  className="btn sm ghost"
                                  onClick={()=>setCollectionStatsFilter({include:[],exclude:[],includeGroups:[],excludeGroups:[]})}
                                >
                                  Clear filters
                                </button>
                              )}
                            </div>
                          </div>
                          <div className="collectionGroupsGrid">
                            {collectionGroups.map(group=>{
                              const visibleMembers = (group.members || []).filter(name=>allCollectionNames.includes(name));
                              const isIncludeGroup = (collectionStatsFilter.includeGroups || []).includes(group.id);
                              const isExcludeGroup = (collectionStatsFilter.excludeGroups || []).includes(group.id);
                              let groupClass = 'ghost';
                              if(isIncludeGroup) groupClass = 'secondary';
                              if(isExcludeGroup) groupClass = 'danger';
                              return (
                                <div className="collectionGroupCard" key={group.id}>
                                  <div className="collectionGroupHeader">
                                    <button
                                      className={'btn sm '+groupClass+' collectionGroupToggle'}
                                      onClick={()=>cycleCollectionStatsGroupFilter(group.id)}
                                    >
                                      <span>{group.name}</span>
                                      <span className="smallMuted">({visibleMembers.length})</span>
                                    </button>
                                    <button
                                      className="btn sm ghost collectionGroupCaret"
                                      aria-label={group.open ? 'Collapse group' : 'Expand group'}
                                      title={group.open ? 'Collapse group' : 'Expand group'}
                                      onClick={()=>toggleGroupOpen(group.id)}
                                    >
                                      <span aria-hidden="true">{group.open ? '‚ñæ' : '‚ñ∏'}</span>
                                    </button>
                                  </div>
                                  {group.open && (
                                    <div className="collectionGroupItems">
                                      {visibleMembers.length>0 ? (
                                        visibleMembers.map(renderCollectionStatsRow)
                                      ) : (
                                        <span className="smallMuted">No collections in this group yet.</span>
                                      )}
                                    </div>
                                  )}
                                </div>
                              );
                            })}
                            {ungroupedCollections.length>0 && (
                              <div className="collectionGroupCard">
                                <div className="collectionGroupHeader">
                                  <span className="smallMuted">Ungrouped</span>
                                  <span className="smallMuted">{ungroupedCollections.length} collections</span>
                                </div>
                                <div className="collectionGroupItems">
                                  {ungroupedCollections.map(renderCollectionStatsRow)}
                                </div>
                              </div>
                            )}
                          </div>
                        </div>
                      )}
                      {filteredCollectionStats.length===0 ? (
                        <p className="hint">No collections match the current filter.</p>
                      ) : (
                        <table>
                          <thead>
                            <tr>
                              <th>#</th>
                              <th>Preview</th>
                              <th className="sortable" onClick={()=>changeCollStatsSort('name')}>
                                Collection{sortIndicator(collStatsSort.field==='name',collStatsSort.dir)}
                              </th>
                              <th className="sortable" onClick={()=>changeCollStatsSort('imagesCount')}>
                                # Images{sortIndicator(collStatsSort.field==='imagesCount',collStatsSort.dir)}
                              </th>
                              <th className="sortable" onClick={()=>changeCollStatsSort('wins')}>
                                W{sortIndicator(collStatsSort.field==='wins',collStatsSort.dir)}
                              </th>
                              <th className="sortable" onClick={()=>changeCollStatsSort('losses')}>
                                L{sortIndicator(collStatsSort.field==='losses',collStatsSort.dir)}
                              </th>
                              <th className="sortable" onClick={()=>changeCollStatsSort('matchups')}>
                                M{sortIndicator(collStatsSort.field==='matchups',collStatsSort.dir)}
                              </th>
                              <th className="sortable" onClick={()=>changeCollStatsSort('tourneyCount')}>
                                T{sortIndicator(collStatsSort.field==='tourneyCount',collStatsSort.dir)}
                              </th>
                              <th className="sortable" onClick={()=>changeCollStatsSort('tourneyWins')}>
                                TW{sortIndicator(collStatsSort.field==='tourneyWins',collStatsSort.dir)}
                              </th>
                              <th className="sortable" onClick={()=>changeCollStatsSort('pct')}>
                                Win%{sortIndicator(collStatsSort.field==='pct',collStatsSort.dir)}
                              </th>
                              <th className="sortable" onClick={()=>changeCollStatsSort('points')}>
                                Points{sortIndicator(collStatsSort.field==='points',collStatsSort.dir)}
                              </th>
                            </tr>
                          </thead>
                          <tbody>
                            {filteredCollectionStats.map((c,i)=>(
                              <tr key={c.name}>
                                <td>{i+1}</td>
                                <td>
                                  {c.bestItem ? (
                                    <div className="thumbWrap">
                                      <SafeImage
                                        item={c.bestItem}
                                        className="thumb"
                                        src={getDisplaySrc(c.bestItem)}
                                        fallbackSrcs={getDisplaySources(c.bestItem)}
                                        alt={c.bestItem.title || 'Image'}
                                        onClick={() => openPreviewFor(c.bestItem)}
                                        onResolved={(url)=>patchItem(c.bestItem.id,{fullUrl:url})}
                                      />
                                    </div>
                                  ) : (
                                    <span className="smallMuted">‚Äî</span>
                                  )}
                                </td>
                                <td>
                                  <button
                                    className="btn sm ghost"
                                    onClick={()=>{
                                      setActiveCollection(c.name);
                                      setActiveCollectionType('collection');
                                      setCollectionTabView('collections');
                                      setCollectionViewMode('gallery');
                                      setCollectionPage(1);
                                    }}
                                  >
                                    {c.name}
                                  </button>
                                </td>
                                <td>{c.imagesCount}</td>
                                <td>{c.wins}</td>
                                <td>{c.losses}</td>
                                <td>{c.matchups}</td>
                                <td>{c.tourneyCount}</td>
                                <td>{c.tourneyWins}</td>
                                <td>{c.pct.toFixed(3)}</td>
                                <td>{c.points}</td>
                              </tr>
                            ))}
                          </tbody>
                        </table>
                      )}
                    </>
                  )}
                </>
              ) : (
                <>
                  {generatorStats.length===0 ? (
                    <p className="hint">No generators yet. Add generator names to your images to see their performance.</p>
                  ) : (
                    <table>
                      <thead>
                        <tr>
                          <th>#</th>
                          <th>Preview</th>
                          <th className="sortable" onClick={()=>changeGenStatsSort('name')}>
                            Generator{sortIndicator(genStatsSort.field==='name',genStatsSort.dir)}
                          </th>
                          <th className="sortable" onClick={()=>changeGenStatsSort('imagesCount')}>
                            # Images{sortIndicator(genStatsSort.field==='imagesCount',genStatsSort.dir)}
                          </th>
                          <th className="sortable" onClick={()=>changeGenStatsSort('wins')}>
                            W{sortIndicator(genStatsSort.field==='wins',genStatsSort.dir)}
                          </th>
                          <th className="sortable" onClick={()=>changeGenStatsSort('losses')}>
                            L{sortIndicator(genStatsSort.field==='losses',genStatsSort.dir)}
                          </th>
                          <th className="sortable" onClick={()=>changeGenStatsSort('matchups')}>
                            M{sortIndicator(genStatsSort.field==='matchups',genStatsSort.dir)}
                          </th>
                          <th className="sortable" onClick={()=>changeGenStatsSort('pct')}>
                            Win%{sortIndicator(genStatsSort.field==='pct',genStatsSort.dir)}
                          </th>
                          <th className="sortable" onClick={()=>changeGenStatsSort('points')}>
                            Points{sortIndicator(genStatsSort.field==='points',genStatsSort.dir)}
                          </th>
                        </tr>
                      </thead>
                      <tbody>
                        {generatorStats.map((g,i)=>(
                          <tr key={g.name}>
                            <td>{i+1}</td>
                            <td>
                              {g.bestItem ? (
                                <div className="thumbWrap">
                                  <SafeImage
                                    item={g.bestItem}
                                    className="thumb"
                                    src={getDisplaySrc(g.bestItem)}
                                    fallbackSrcs={getDisplaySources(g.bestItem)}
                                    alt={g.bestItem.title || 'Image'}
                                    onClick={() => openPreviewFor(g.bestItem)}
                                    onResolved={(url)=>patchItem(g.bestItem.id,{fullUrl:url})}
                                  />
                                </div>
                              ) : (
                                <span className="smallMuted">‚Äî</span>
                              )}
                            </td>
                            <td>
                              <button
                                className="btn sm ghost"
                                onClick={()=>{
                                  setActiveCollection(g.name);
                                  setActiveCollectionType('generator');
                                  setCollectionTabView('generators');
                                  setCollectionViewMode('gallery');
                                  setCollectionPage(1);
                                }}
                              >
                                {g.name}
                              </button>
                            </td>
                            <td>{g.imagesCount}</td>
                            <td>{g.wins}</td>
                            <td>{g.losses}</td>
                            <td>{g.matchups}</td>
                            <td>{g.pct.toFixed(3)}</td>
                            <td>{g.points}</td>
                          </tr>
                        ))}
                      </tbody>
                    </table>
                  )}
                </>
              )}
            </section>
          )}

          {tab==='Collections' && activeCollection && (
            <section className="pane">
              <div className="toolbar" style={{justifyContent:'space-between',marginBottom:8}}>
                <div className="flexRow">
                  <button className="btn sm ghost" onClick={()=>{setActiveCollection(null); setSelectedIds([]); setActiveCollectionType(collectionTabView==='generators'?'generator':'collection');}}>
                    ‚Üê Back to all {collectionTabView==='generators'?'generators':'collections'}
                  </button>
                  <span className="pill">{activeCollection}</span>
                  <span className="pill">{activeCollectionType==='generator' ? 'Generator' : 'Collection'}</span>
                  <span className="smallMuted">
                    {activeCollectionItems.length} images ‚Ä¢ {activeCollectionItems.reduce((a,it)=>a+it.wins,0)} W / {activeCollectionItems.reduce((a,it)=>a+it.losses,0)} L
                  </span>
                </div>
                <div className="flexRow">
                  <button
                    className="btn sm"
                    onClick={()=>startCollectionMatchups(activeCollection, activeCollectionType)}
                    disabled={activeCollectionItems.length<2}
                  >
                    Matchups in this {activeCollectionType}
                  </button>
                  <button
                    className="btn sm ghost"
                    onClick={()=>setCollectionViewMode('gallery')}
                  >
                    Gallery
                  </button>
                  <button
                    className="btn sm ghost"
                    onClick={()=>setCollectionViewMode('cards')}
                  >
                    Cards
                  </button>
                </div>
              </div>

              <div className="toolbar" style={{justifyContent:'space-between',marginBottom:8}}>
                <div className="flexRow">
                  <label className="smallMuted">
                    Sort by{' '}
                    <select
                      className="select"
                      value={collectionSort.field}
                      onChange={e=>setCollectionSort(s=>({...s, field:e.target.value}))}
                    >
                      <option value="addedAt">Date added</option>
                      <option value="title">Title</option>
                      <option value="points">Points</option>
                      <option value="matchups"># Matchups</option>
                    </select>
                  </label>
                  <label className="smallMuted">
                    Direction{' '}
                    <select
                      className="select"
                      value={collectionSort.dir}
                      onChange={e=>setCollectionSort(s=>({...s, dir:e.target.value}))}
                    >
                      <option value="desc">Desc</option>
                      <option value="asc">Asc</option>
                    </select>
                  </label>
                </div>
                {collectionViewMode==='gallery' && (
                  <div className="flexRow">
                    <label className="smallMuted">
                      Columns{' '}
                      <select
                        className="select"
                        value={String(collectionGalleryColumns)}
                        onChange={e=>setCollectionGalleryColumns(Number(e.target.value))}
                      >
                        {galleryColumnOptions.map(opt=>(
                          <option key={opt} value={opt}>{opt} columns</option>
                        ))}
                      </select>
                    </label>
                  </div>
                )}
              </div>

              <div className="toolbar" style={{justifyContent:'space-between',marginBottom:6}}>
                <div className="flexRow">
                  <button
                    className="btn sm secondary"
                    onClick={()=>{
                      if(allCollPageSelected) clearSelection();
                      else selectAllVisible(collectionPageItems);
                    }}
                  >
                    {allCollPageSelected ? 'Clear all on page' : 'Select all on page'}
                  </button>
                  <button
                    className="btn sm secondary"
                    onClick={()=>{
                      if(allCollSelected) clearSelection();
                      else setSelectedIds(activeCollectionItems.map(it=>it.id));
                    }}
                  >
                    {allCollSelected
                      ? `Clear all in ${activeCollectionType}`
                      : `Select all in ${activeCollectionType}`}
                  </button>
                  {selectedIds.length>0 && (
                    <button
                      className="btn sm ghost"
                      onClick={()=>{
                        setBatchReplaceFrom(activeCollectionType==='collection' ? activeCollection : '');
                        setBatchReplaceTo('');
                        setBatchGenerator('__keep__');
                        setBatchOpen(true);
                      }}
                    >
                      Batch edit ({selectedIds.length})
                    </button>
                  )}
                </div>
                <div className="flexRow">
                  <input
                    type="file"
                    accept="image/*"
                    multiple
                    style={{display:'none'}}
                    id="collectionUploadInput"
                    onChange={e=>{
                      const forcedCollections = activeCollectionType==='collection' ? [activeCollection] : null;
                      const forcedGenerator = activeCollectionType==='generator' ? activeCollection : null;
                      handleFiles(e.target.files,forcedCollections,forcedGenerator);
                    }}
                  />
                  <button
                    className="btn sm"
                    onClick={()=>{
                      const el = document.getElementById('collectionUploadInput');
                      el && el.click();
                    }}
                  >
                    {activeCollectionType==='generator' ? 'Add images to this generator' : 'Add images to this collection'}
                  </button>
                </div>
              </div>

              {activeCollectionItems.length>0 && (
                <div className="pager">
                  <div>Page {collPage} of {collTotalPages}</div>
                  <div className="flexRow">
                    <label className="smallMuted">
                      Per page{' '}
                      <select
                        className="select"
                        value={String(collectionPageSize)}
                        onChange={e=>{
                          const v = e.target.value === 'all' ? 'all' : Number(e.target.value);
                          setCollectionPageSize(v);
                          setCollectionPage(1);
                        }}
                      >
                        <option value="25">25</option>
                        <option value="50">50</option>
                        <option value="100">100</option>
                        <option value="250">250</option>
                        <option value="500">500</option>
                        <option value="all">All</option>
                      </select>
                    </label>
                    <button
                      className="btn sm ghost"
                      onClick={()=>setCollectionPage(p=>Math.max(1,p-1))}
                      disabled={collPage<=1}
                    >
                      Prev
                    </button>
                    <button
                      className="btn sm ghost"
                      onClick={()=>setCollectionPage(p=>Math.min(collTotalPages,p+1))}
                      disabled={collPage>=collTotalPages}
                    >
                      Next
                    </button>
                  </div>
                </div>
              )}

              {activeCollectionItems.length===0 && (
                <p className="hint">No images in this collection yet.</p>
              )}

              {activeCollectionItems.length>0 && collectionViewMode==='gallery' && (
                <div
                  className="galleryGrid"
                  style={{marginTop:8, gridTemplateColumns:`repeat(${collectionGalleryColumns}, minmax(0,1fr))`}}
                >
                  {collectionPageItems.map(it=>{
                    const isSel = selectedIds.includes(it.id);
                    return (
                      <div
                        key={it.id}
                        className="galleryItem"
                        onClick={()=>{
                          if(selectionMode){
                            toggleSelected(it.id);
                          }else{
                            openPreviewFor(it);
                          }
                        }}
                      >
<img
  className="galleryImg"
  src={it.thumbnail || it.fullUrl || it.dataUrl}
  alt={it.title || 'Image'}
/>

                        <div className="galleryOverlay" />
                        {renderBadges(it.id,'badgeRow-top-right')}
                        <div className="galleryMeta">
                          <div
                            className="galleryCheckWrap"
                            onClick={e=>{e.stopPropagation();toggleSelected(it.id);}}
                          >
                            <span className={'checkbox'+(isSel?' checked':'')}></span>
                          </div>
                        </div>
                      </div>
                    );
                  })}
                </div>
              )}

              {activeCollectionItems.length>0 && collectionViewMode==='cards' && (
                <ul className="grid" style={{marginTop:8}}>
                  {collectionPageItems.map(it=>(
                    <li key={it.id} className="card">
                      <div className="cardThumb" onClick={()=>openPreviewFor(it)}>
                        <img
  src={it.thumbnail || it.fullUrl || it.dataUrl}
  alt={it.title || 'Image'}
/>

                        {renderBadges(it.id,'badgeRow-top-right')}
                      </div>
                      <div className="cardBody">
                        <div className="fieldRow">
                          <label>Title</label>
                          <input
                            value={it.title}
                            onChange={e=>patchItem(it.id,{title:e.target.value})}
                          />
                        </div>
                        <div className="fieldRow">
                          <label>Collections</label>
                          <input
                            value={collectionsToString(it.collections)}
                            onChange={e=>patchItem(it.id,{collections:normalizeCollections(e.target.value)})}
                          />
                        </div>
                        <div className="fieldRow">
                          <label>AI Generator</label>
                          <select
                            className="select"
                            value={it.generator || ''}
                            onChange={e=>patchItem(it.id,{generator:e.target.value})}
                          >
                            {generatorSelectOptions.map(opt=>(
                              <option key={opt.label} value={opt.value}>{opt.label}</option>
                            ))}
                          </select>
                        </div>
                        <div className="statLine">
                          <span>W: {it.wins}</span>
                          <span>L: {it.losses}</span>
                          <span>Win%: {pct(it.wins,it.losses).toFixed(3)}</span>
                          <span>Pts: {computePoints(it.wins,it.losses,it.tourneyBonus||0)}</span>
                          <span>M: {matchupsCount(it)}</span>
                        </div>
                        <div className="toolbar" style={{marginTop:4}}>
                          <button className="btn ghost sm" onClick={()=>startCropFor(it)}>Crop</button>
                          <button className="btn danger sm" onClick={()=>removeItem(it.id)}>Delete</button>
                        </div>
                      </div>
                    </li>
                  ))}
                </ul>
              )}
            </section>
          )}

          {/* PREVIEW MODAL */}
          {previewItem && (
            <div className="modal" onClick={()=>setPreviewId(null)}>
              <div className="modalInner" onClick={e=>e.stopPropagation()}>
                <div className="previewImgWrap">
<img
  src={
    previewSrc ||
    previewItem.thumbnail ||
    previewItem.fullUrl ||
    previewItem.dataUrl
  }
  alt={previewItem.title || 'Image'}
/>

                  {renderBadges(previewItem.id,'badgeRow-top-right')}
                </div>
                <div className="modalFields">
                  <div>
                    <div>Title</div>
                    <input
                      value={previewItem.title}
                      onChange={e=>patchItem(previewItem.id,{title:e.target.value})}
                    />
                  </div>
                  <div>
                    <div>Image #</div>
                    <div className="smallMuted">{previewItem.id}</div>
                  </div>
                  <div>
                    <div>Collections (comma-separated)</div>
                    <input
                      value={previewCollectionsText}
                      onChange={e=>setPreviewCollectionsText(e.target.value)}
                      onBlur={()=>{
                        const arr = normalizeCollections(previewCollectionsText);
                        patchItem(previewItem.id,{collections:arr});
                        setPreviewCollectionsText(collectionsToString(arr));
                      }}
                    />
                  </div>
                  <div>
                    <div>AI Generator</div>
                    <select
                      className="select"
                      value={previewItem.generator || ''}
                      onChange={e=>patchItem(previewItem.id,{generator:e.target.value})}
                    >
                      {generatorSelectOptions.map(opt=>(
                        <option key={opt.label} value={opt.value}>{opt.label}</option>
                      ))}
                    </select>
                  </div>
                  <div>
                    <div>Stats (editable)</div>
                    <div className="statEditGrid">
                      <label>
                        <div>Wins</div>
                        <input
                          type="number"
                          min="0"
                          value={previewWins}
                          onChange={e=>{
                            const next = e.target.value;
                            setPreviewWins(next);
                            patchItem(previewItem.id,{wins:Number(next || 0)});
                          }}
                        />
                      </label>
                      <label>
                        <div>Losses</div>
                        <input
                          type="number"
                          min="0"
                          value={previewLosses}
                          onChange={e=>{
                            const next = e.target.value;
                            setPreviewLosses(next);
                            patchItem(previewItem.id,{losses:Number(next || 0)});
                          }}
                        />
                      </label>
                      <label>
                        <div>Tournaments</div>
                        <input
                          type="number"
                          min="0"
                          value={previewTourneyCount}
                          onChange={e=>{
                            const next = e.target.value;
                            setPreviewTourneyCount(next);
                            patchItem(previewItem.id,{tourneyCount:Number(next || 0)});
                          }}
                        />
                      </label>
                      <label>
                        <div>Tournament wins</div>
                        <input
                          type="number"
                          min="0"
                          value={previewTourneyWins}
                          onChange={e=>{
                            const next = e.target.value;
                            setPreviewTourneyWins(next);
                            patchItem(previewItem.id,{tourneyBonus:Number(next || 0) * 5});
                          }}
                        />
                      </label>
                      <label>
                        <div>Date added</div>
                        <input
                          type="datetime-local"
                          value={previewAddedAt}
                          onChange={e=>{
                            const next = e.target.value;
                            setPreviewAddedAt(next);
                            patchItem(previewItem.id,{addedAt: next ? fromDateTimeLocalValue(next) : ''});
                          }}
                        />
                      </label>
                    </div>
                    <div className="smallMuted" style={{marginTop:8}}>
                      W {previewItem.wins} ‚Ä¢ L {previewItem.losses} ‚Ä¢ M {matchupsCount(previewItem)}<br/>
                      Win% {pct(previewItem.wins,previewItem.losses).toFixed(3)} ‚Ä¢ Points {computePoints(previewItem.wins,previewItem.losses,previewItem.tourneyBonus||0)}<br/>
                      <div style={{whiteSpace:'pre-line'}}>
                        Added {formatAddedAt(previewItem.addedAt)}
                      </div>
                    </div>
                  </div>
                </div>
                <div className="modalFooter">
                  <button className="btn ghost" onClick={()=>startCropFor(previewItem)}>Crop</button>
                  <button className="btn ghost" onClick={()=>startLockedMatchup(previewItem)}>
                    Lock matchup
                  </button>
                  <button
                    className="btn danger"
                    onClick={()=>{
                      removeItem(previewItem.id);
                      setPreviewId(null);
                    }}
                  >
                    Delete
                  </button>
                  <button className="btn" onClick={()=>setPreviewId(null)}>Close</button>
                </div>
              </div>
            </div>
          )}

          {/* CROPPER MODAL */}
          {cropper.crop && (
            <div className="modal" onClick={()=>cropper.setCrop(null)}>
              <div className="modalInner" onClick={e=>e.stopPropagation()}>
                <canvas
                  ref={cropper.ref}
                  className="cropCanvas"
                  onMouseDown={cropper.onPointerDown}
                  onTouchStart={e=>{e.preventDefault();cropper.onPointerDown(e);}}
                ></canvas>
                <div className="cropHint">
                  Drag inside the square to move. Drag corners to resize. Click Apply to save crop.
                </div>
                <div className="modalFooter">
                  <button className="btn ghost" onClick={()=>cropper.setCrop(null)}>Cancel</button>
                  <button className="btn" onClick={applyCrop}>Apply crop</button>
                </div>
              </div>
            </div>
          )}

          {/* BATCH EDIT MODAL */}
          {batchOpen && (
            <div className="modal" onClick={()=>setBatchOpen(false)}>
              <div className="modalInner" onClick={e=>e.stopPropagation()}>
                <h3 style={{margin:'4px 0 6px',fontSize:16}}>Batch edit ({selectedIds.length} images)</h3>
                <p className="smallMuted">
                  Collections can be added, removed, or renamed. Generator changes are applied only if you choose a value.
                </p>
                <div className="modalFields">
                  <div>
                    <div>Collections to add (comma-separated)</div>
                    <input
                      value={batchCollectionsText}
                      onChange={e=>setBatchCollectionsText(e.target.value)}
                      placeholder="e.g. teal, autumn, side-view"
                    />
                  </div>
                  <div>
                    <div>Collections to remove (comma-separated)</div>
                    <input
                      value={batchRemoveCollectionsText}
                      onChange={e=>setBatchRemoveCollectionsText(e.target.value)}
                      placeholder="e.g. draft, needs-review"
                    />
                  </div>
                  <div>
                    <div>Rename collection (from ‚Üí to)</div>
                    <div className="flexRow">
                      <input
                        value={batchReplaceFrom}
                        onChange={e=>setBatchReplaceFrom(e.target.value)}
                        placeholder="Current collection name"
                      />
                      <input
                        value={batchReplaceTo}
                        onChange={e=>setBatchReplaceTo(e.target.value)}
                        placeholder="New collection name"
                      />
                    </div>
                  </div>
                  <div>
                    <div>Set AI Generator (optional)</div>
                    <select
                      className="select"
                      value={batchGenerator}
                      onChange={e=>setBatchGenerator(e.target.value)}
                    >
                      <option value="__keep__">Leave unchanged</option>
                      {generatorSelectOptions.map(opt=>(
                        <option key={opt.label} value={opt.value}>{opt.label}</option>
                      ))}
                    </select>
                  </div>
                </div>
                <div className="modalFooter">
                  <button className="btn ghost" onClick={()=>setBatchOpen(false)}>Cancel</button>
                  <button
                    className="btn"
                    onClick={()=>{
                      const addCols = normalizeCollections(batchCollectionsText);
                      const removeCols = normalizeCollections(batchRemoveCollectionsText);
                      const replaceFrom = batchReplaceFrom.trim();
                      const replaceTo = batchReplaceTo.trim();
                      const genChoice = batchGenerator;
                      const removeSet = new Set(removeCols);
                      setItems(prev=>{
                        const next = prev.map(it=>{
                          if(!selectedIds.includes(it.id)) return it;
                          const updated = {...it};
                          let collections = Array.isArray(updated.collections) ? [...updated.collections] : [];
                          if(replaceFrom){
                            if(replaceTo){
                              collections = collections.map(c=>c===replaceFrom ? replaceTo : c);
                            }else{
                              collections = collections.filter(c=>c!==replaceFrom);
                            }
                          }
                          if(removeSet.size){
                            collections = collections.filter(c=>!removeSet.has(c));
                          }
                          if(addCols.length){
                            collections = [...collections, ...addCols];
                          }
                          if(replaceFrom || removeSet.size || addCols.length){
                            const seen = new Set();
                            updated.collections = collections.filter(c=>{
                              if(!c) return false;
                              if(seen.has(c)) return false;
                              seen.add(c);
                              return true;
                            });
                          }
                          if(genChoice !== '__keep__'){
                            updated.generator = genChoice;
                          }
                          idbPut(updated);
                          return updated;
                        });
                        return next;
                      });
                      setSelectedIds([]);
                      setBatchCollectionsText('');
                      setBatchRemoveCollectionsText('');
                      setBatchReplaceFrom('');
                      setBatchReplaceTo('');
                      setBatchGenerator('__keep__');
                      setBatchOpen(false);
                    }}
                  >
                    Apply to selected
                  </button>
                </div>
              </div>
            </div>
          )}
{/* --- CLEANUP / ORPHAN MODAL --- */}
      {cleanupModalOpen && (
        <div className="modal" onClick={()=>setCleanupModalOpen(false)}>
          <div className="modalInner" onClick={e=>e.stopPropagation()}>
            <h3 style={{margin:'4px 0 6px',fontSize:16}}>Sync Deletions (Cleanup)</h3>
            
            {!orphans && (
              <>
                <p className="smallMuted" style={{marginBottom:15}}>
                  To remove images from Mobile that you already deleted on Desktop:<br/><br/>
                  1. Export a <b>FULL</b> Metadata file from Desktop.<br/>
                  2. Upload it here.<br/>
                  3. We will identify any images here that are missing from that file.
                </p>
                <div style={{textAlign:'center', padding:20, border:'1px dashed #1b3a2f', borderRadius:8}}>
<button
  className="btn"
  onClick={()=>{
    if (cleanupFileRef.current) {
      cleanupFileRef.current.click();
    }
  }}
>
  Select Desktop Metadata File
</button>

                  <input 
                    type="file" 
                    ref={cleanupFileRef} 
                    style={{display:'none'}} 
                    accept=".json"
onChange={e => {
  const files = e.target && e.target.files;
  if (files && files[0]) {
    analyzeForOrphans(files[0]);
  }
  e.target.value = '';
}}

                  />
                </div>
              </>
            )}

            {orphans && orphans.length === 0 && (
              <div style={{textAlign:'center', padding:20}}>
                <div style={{fontSize:30}}>‚úÖ</div>
                <p>Your library is perfectly synced.<br/>No orphans found.</p>
              </div>
            )}

            {orphans && orphans.length > 0 && (
              <div>
                <div style={{color:'#ff5f71', marginBottom:10}}>
                  ‚ö†Ô∏è Found <b>{orphans.length}</b> images on this device that are NOT in your Desktop export.
                </div>
                <div style={{maxHeight:'40vh', overflowY:'auto', background:'rgba(0,0,0,0.3)', borderRadius:6, padding:8, marginBottom:10}}>
                  {orphans.map(o => (
                    <div key={o.id} style={{fontSize:12, borderBottom:'1px solid #1b3a2f', padding:'4px 0', display:'flex', justifyContent:'space-between'}}>
                      <span>{o.title || 'Untitled'}</span>
                      <span style={{opacity:0.5}}>{o.id.slice(0,8)}...</span>
                    </div>
                  ))}
                </div>
                <p className="smallMuted">
                  Clicking delete will remove these from this device only.
                </p>
              </div>
            )}

            <div className="modalFooter">
              <button className="btn ghost" onClick={()=>setCleanupModalOpen(false)}>Close</button>
              {orphans && orphans.length > 0 && (
                <button className="btn danger" onClick={deleteOrphans}>
                  Delete {orphans.length} Orphans
                </button>
              )}
            </div>
          </div>
        </div>
      )}
      {/* --- END CLEANUP / ORPHAN MODAL --- */}
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<App />);


  
</script>
</body>
</html>
